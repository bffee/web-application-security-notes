# Exploiting LDAP Injection

While LDAP injection is generally harder to exploit than SQL injection, **real-world applications** can still be vulnerable, especially when the LDAP search filter logic or input handling is weak.

Successful exploitation depends on:
* The **structure of the LDAP filter**.
* The **input injection point**.
* The behavior of the **underlying LDAP implementation**.

---

## **Disjunctive Queries**

In disjunctive filters (`|`), each condition is treated independently, and **any** matching condition allows a result.

### **Example Scenario**

An application restricts employees by department **and** geographic location:

```ldap
(|(department=London sales)(department=Reading sales))
```

This filter is constructed to enforce access control ‚Äî only employees in **authorized locations** should be visible.

### **Attack: Wildcard Bypass**

If the user-supplied department is inserted into this query, an attacker can inject:

```text
)(department=*
```

The resulting filter becomes:

```ldap
(|(department=London )(department=*)(department=Reading )(department=*))
```

Since `department=*` matches **any department**, **all employees across all locations** are returned ‚Äî **access control is bypassed**.

**TRY IT:**
* http://mdsec.net/employees/31/
* http://mdsec.net/employees/49/

---

## **Conjunctive Queries**

In conjunctive filters (`&`), **all** conditions must be met for a match.

### **Example Scenario**

A user authorized for only London tries to search for "daf":

```ldap
(&(givenName=daf)(department=London*))
```

### **Attack #1: Batching Disjoint Filters**

In some LDAP implementations (e.g., **OpenLDAP**), multiple filters can be batched and interpreted as **disjunctive**.

#### **Injected Input:**

```text
*))(&(givenName=daf
```

#### **Resulting Filter:**

```ldap
(&(givenName=*))(&(givenName=daf)(department=London*))
```

This behaves like two separate filters:
1. `(&(givenName=*))` ‚Äî matches everyone.
2. `(&(givenName=daf)(department=London*))` ‚Äî original intent.

Since one of them matches everyone, **all employee data is returned**.

**TRY IT:**
* http://mdsec.net/employees/42/

> üìù **NOTE:** This **batched filter injection** works even on **simple match filters** without any explicit logical operator, depending on the LDAP backend.

---

### **Attack #2: NULL Byte Truncation**

Some LDAP libraries (especially those written in native code like C) **terminate strings** at NULL bytes.

LDAP doesn't support inline comments (like SQL's `--`), but **a NULL byte can emulate this behavior**.

#### **Injected Input:**

```text
*))%00
```

Where `%00` gets decoded into a **literal NULL byte**.

#### **Resulting Filter:**

```ldap
(&(givenName=*))[NULL])(department=London*))
```

After the NULL, the rest of the filter is ignored. LDAP now only sees:

```ldap
(&(givenName=*))
```

This returns **all employees**, including those outside the intended `London` scope.

---

## **Summary**

* **Disjunctive queries** are vulnerable to wildcard-based injections.
* **Conjunctive queries** can be exploited using:
  * **Batching of filters** (interpreted disjunctively).
  * **NULL byte truncation** to comment out query logic.
* The **effectiveness** of each attack depends heavily on:
  * The **backend LDAP server** (e.g., OpenLDAP vs. Active Directory).
  * How **input is embedded** in the filter.

Even in constrained environments, LDAP injection can **bypass access controls** and **leak sensitive directory data**.

