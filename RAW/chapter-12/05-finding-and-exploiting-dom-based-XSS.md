## ğŸ§  **Understanding DOM-Based XSS**

### What Makes DOM-Based XSS Different?

DOM-based XSS:

* **Does not involve the server reflecting your payload**
* Happens **entirely within the browser**, via **client-side JavaScript**
* Often **invisible to traditional scanners** (they look at request/response only)
* Frequently found in **Single Page Applications (SPAs)** or React/Angular/Vanilla JS apps

> âœ… **TL;DR**: The appâ€™s JavaScript takes untrusted data from the DOM (URL, referrer, fragment, etc.), and inserts it into the page or evals it.

---

## ğŸ” How to **Detect DOM-Based XSS** (Penetration Tester Workflow)

### âŒ Old-School Scanner Approach Fails

* You inject a payload like:

  ```html
  <script>alert(1)</script>
  ```
* Then look for that string in the **server response**
* If not found, you wrongly assume itâ€™s safe

### âœ… Manual Walkthrough Approach

You walk the site **with your browser**, manually injecting payloads in the URL:

```plaintext
https://target.com/page?search=<script>alert(1)</script>
```

Standard payloads to test:

```js
<script>alert(1)</script>
';alert(1)// 
'-alert(1)-'
```

Why this works:

* When the JavaScript runs and **reads from `document.location`, `document.referrer`, etc.**, your payload could be executed dynamically â€” **not visible in the raw HTML**.

---

## ğŸ” DOM XSS Detection via **Code Review**

### ğŸ›  Target DOM APIs (Sinks)

These are **where the vulnerability gets triggered**:

* `document.write()`
* `document.writeln()`
* `document.body.innerHTML`
* `eval()` âš ï¸
* `window.execScript()` âš ï¸
* `setInterval()`, `setTimeout()` (when passed a string)

### ğŸ¯ Target DOM APIs (Sources)

These are **user-controlled inputs** in the DOM:

* `document.location`
* `document.URL`
* `document.referrer`
* `window.location`
* `document.URLUnencoded`

### ğŸ” Source â†’ Sink = âš ï¸ DOM XSS Risk

If unescaped/unvalidated data from source flows into a sink, thatâ€™s **DOM XSS**.

---

## ğŸ“œ Example: Classic DOM-Based XSS

```html
<script>
  const param = location.search.substring(1);
  document.write(param);
</script>
```

URL:

```
https://target.com/page?<img src=x onerror=alert(1)>
```

ğŸ’¥ DOM XSS fires even though server **never sees the payload.**

---

## ğŸ›  Tools to Automate Discovery

* **DOMTracer**: Static analysis of JS sources to trace DOM-based flows
  ğŸ‘‰ [http://www.blueinfy.com/tools.html](http://www.blueinfy.com/tools.html) *(may be outdated)*

* **Burp Suite** with **DOM Invader** (built into Burp Pro)

  * Real-time DOM sink detection
  * Shows tainted variables, triggering lines, etc.

---

## ğŸ” Bypassing Filters & Common Mistakes in Client-Side Parsing

### 1. **Fake Parameters to Bypass Filters**

Server filters `message` param. But client-side code just scans `location.href` for `message=`, so you inject after the real param:

```plaintext
https://target.com/page?message=Error&foo=<script>alert(1)</script>
```

Client-side JavaScript:

```js
let param = location.href.split("message=")[1];
document.write(param);
```

ğŸ’¥ XSS fires because `foo=` contains the payload and the server ignores it.

---

### 2. **Fragment Injection** â€” `#` is Your Best Friend

* Fragment identifiers (after `#`) **never reach the server**
* But they are still accessible in JavaScript (`location.hash`, `location.href`)

Payload:

```
https://target.com/page?message=Error#<script>alert(1)</script>
```

Server canâ€™t block what it never sees â†’ JS processes it â†’ XSS fires.

---

### 3. **Delimiter Confusion Attacks**

Some apps parse query strings naively:

```js
const message = location.href.split("message=")[1];
```

So you trick it by injecting your payload *before* the actual message param:

```plaintext
https://target.com/page?foomessage=<script>alert(1)</script>&message=Error
```

Or inside the fragment:

```plaintext
https://target.com/page#message=<script>alert(1)</script>
```

ğŸ’¥ Both can trigger DOM XSS if JS just uses `.split("message=")`.

---

## ğŸ” Advanced Detection via Debugging

When JS is complex, use a **JS Debugger** like:

* **FireBug** (legacy)
* **DevTools** in Chrome/Firefox

  * Use **Breakpoints**, **Watchers**
  * Pause at DOM sinks (`innerHTML`, `eval`, etc.)
  * Monitor values coming from `location` or other sources

---

## ğŸ§ª TEST LABS â€” Use These URLs

Try each one in a browser to observe DOM XSS behavior:

```plaintext
http://mdsec.net/error/18/
http://mdsec.net/error/22/
http://mdsec.net/error/28/
http://mdsec.net/error/31/
http://mdsec.net/error/37/
http://mdsec.net/error/41/
http://mdsec.net/error/49/
http://mdsec.net/error/53/
http://mdsec.net/error/56/
http://mdsec.net/error/61/
http://mdsec.net/error/76/
http://mdsec.net/error/79/
http://mdsec.net/error/82/
http://mdsec.net/error/92/
http://mdsec.net/error/95/
http://mdsec.net/error/107/
http://mdsec.net/error/109/
http://mdsec.net/error/118/
```

These are intentionally vulnerable samples.

---

## ğŸ’¥ DEBUNKING COMMON MYTHS

> âŒ â€œWe filter all requests for `<script>` tags.â€

Wrong, because:

* DOM XSS may not use `<script>`
* Payload may be in an event handler:

  ```html
  <img src=x onerror=alert(1)>
  ```
* Or injected directly into an already open `<script>` tag or JS context
* Or only exist in `#fragment`, which **never hits the server**

> âŒ â€œOur scanner found no XSS, so weâ€™re safe.â€

Wrong again:

* Scanners donâ€™t simulate client-side JS properly
* Complex XSS vectors require manual analysis, browser behavior knowledge, and taint tracking

---

## âœ… Penetration Testerâ€™s Checklist for DOM XSS

| âœ… Test                                   | Description              |
| ---------------------------------------- | ------------------------ |
| URL parameter payload injection          | Classic DOM XSS          |
| Fragment (`#`) injection                 | Bypass server validation |
| Dummy parameters                         | Fool client-side parser  |
| Code audit for `eval`, `innerHTML`, etc. | Sink detection           |
| Use Burp DOM Invader / DOMTracer         | Automation aid           |
| Use browser DevTools / breakpoints       | Dynamic analysis         |
| Test in multiple browsers                | Legacy behavior varies   |
| Try different payload syntaxes           | No `<script>` required   |

---

## ğŸ’¡ Key Takeaways

* DOM-based XSS is **entirely client-side**, often invisible to scanners and backend logs
* Use a **source-to-sink approach** when auditing
* Exploit **naive string parsing**, **fragments**, and **invented params**
* Use debugging tools and **simulate full browser behavior** when testing
* Don't rely on filters that just block `<script>` or blacklist certain strings

---
